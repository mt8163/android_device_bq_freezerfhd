---
 gatekeeperd/Android.mk                |   4 +
 gatekeeperd/gatekeeperd.cpp           |   5 +-
 init/init.cpp                         |   2 +-
 init/init.h                           |   2 +-
 init/service.cpp                      |   2 +
 libcutils/fs_config.cpp               |   4 +-
 liblog/logger_write.c                 |  27 +++
 libnetutils/Android.bp                |   6 +-
 libnetutils/ifc_utils.c               | 269 ++++++++++++++++++++++++++
 libnetutils/include/netutils/ifc.h    |  16 ++
 libsuspend/Android.bp                 |   2 +
 libsuspend/autosuspend.c              |  13 ++
 libsuspend/autosuspend_autosleep.c    | 102 ++++++++++
 libsuspend/autosuspend_earlysuspend.c | 220 +++++++++++++++++++++
 14 files changed, 668 insertions(+), 6 deletions(-)
 create mode 100644 libsuspend/autosuspend_autosleep.c
 create mode 100644 libsuspend/autosuspend_earlysuspend.c

diff --git a/gatekeeperd/Android.mk b/gatekeeperd/Android.mk
index 28f0b07ab..acb1114d1 100644
--- a/gatekeeperd/Android.mk
+++ b/gatekeeperd/Android.mk
@@ -38,6 +38,10 @@ LOCAL_SHARED_LIBRARIES := \
 	libhwbinder \
 	android.hardware.gatekeeper@1.0 \
 
+ifeq ($(strip $(BOARD_USE_SOFT_GATEKEEPER)),true)
+LOCAL_CFLAGS += -DUSE_SOFT_GATEKEEPER
+endif
+
 LOCAL_STATIC_LIBRARIES := libscrypt_static
 LOCAL_C_INCLUDES := external/scrypt/lib/crypto
 LOCAL_INIT_RC := gatekeeperd.rc
diff --git a/gatekeeperd/gatekeeperd.cpp b/gatekeeperd/gatekeeperd.cpp
index 61c880409..1a061d553 100644
--- a/gatekeeperd/gatekeeperd.cpp
+++ b/gatekeeperd/gatekeeperd.cpp
@@ -57,8 +57,11 @@ class GateKeeperProxy : public BnGateKeeperService {
 public:
     GateKeeperProxy() {
         clear_state_if_needed_done = false;
+#ifdef USE_SOFT_GATEKEEPER
+	hw_device = nullptr;
+#else
         hw_device = IGatekeeper::getService();
-
+#endif
         if (hw_device == nullptr) {
             ALOGW("falling back to software GateKeeper");
             soft_device.reset(new SoftGateKeeperDevice());
diff --git a/init/init.cpp b/init/init.cpp
index 35fc442d0..f3814a357 100644
--- a/init/init.cpp
+++ b/init/init.cpp
@@ -88,7 +88,7 @@ static char qemu[32];
 std::string default_console = "/dev/console";
 static time_t process_needs_restart_at;
 
-const char *ENV[32];
+const char *ENV[64];
 
 static int epoll_fd = -1;
 
diff --git a/init/init.h b/init/init.h
index aaab523ee..02ba0f2d3 100644
--- a/init/init.h
+++ b/init/init.h
@@ -27,7 +27,7 @@ namespace init {
 // Note: These globals are *only* valid in init, so they should not be used in ueventd,
 // watchdogd, or any files that may be included in those, such as devices.cpp and util.cpp.
 // TODO: Have an Init class and remove all globals.
-extern const char *ENV[32];
+extern const char *ENV[64];
 extern std::string default_console;
 extern struct selabel_handle *sehandle;
 extern struct selabel_handle *sehandle_prop;
diff --git a/init/service.cpp b/init/service.cpp
index 7c50165c1..30ae4d6b6 100644
--- a/init/service.cpp
+++ b/init/service.cpp
@@ -83,12 +83,14 @@ static std::string ComputeContextFromExecutable(std::string& service_name,
         computed_context = new_con;
         free(new_con);
     }
+    #if 0
     if (rc == 0 && computed_context == mycon.get()) {
         LOG(ERROR) << "service " << service_name << " does not have a SELinux domain defined";
         if (selinux_status_getenforce() > 0) {
             return "";
         }
     }
+    #endif
     if (rc < 0) {
         LOG(ERROR) << "could not get context while starting '" << service_name << "'";
         return "";
diff --git a/libcutils/fs_config.cpp b/libcutils/fs_config.cpp
index 52d62cf07..30ea973a4 100644
--- a/libcutils/fs_config.cpp
+++ b/libcutils/fs_config.cpp
@@ -184,8 +184,8 @@ static const struct fs_path_config android_files[] = {
                                               "system/bin/run-as" },
 
     // Support FIFO scheduling mode in SurfaceFlinger.
-    { 00755, AID_SYSTEM,    AID_GRAPHICS,  CAP_MASK_LONG(CAP_SYS_NICE),
-                                              "system/bin/surfaceflinger" },
+//    { 00755, AID_SYSTEM,    AID_GRAPHICS,  CAP_MASK_LONG(CAP_SYS_NICE),
+//                                              "system/bin/surfaceflinger" },
 
     // Support hostapd administering a network interface.
     { 00755, AID_WIFI,      AID_WIFI,      CAP_MASK_LONG(CAP_NET_ADMIN) |
diff --git a/liblog/logger_write.c b/liblog/logger_write.c
index 84feb206b..c6b54de37 100644
--- a/liblog/logger_write.c
+++ b/liblog/logger_write.c
@@ -34,6 +34,10 @@
 #include "log_portability.h"
 #include "logger.h"
 
+#ifndef FAKE_LOG_DEVICE
+#include <sys/system_properties.h>
+#endif
+
 #define LOG_BUF_SIZE 1024
 
 static int __write_to_log_init(log_id_t, struct iovec* vec, size_t nr);
@@ -701,3 +705,26 @@ LIBLOG_ABI_PUBLIC int android_get_log_transport() {
 
   return ret;
 }
+#ifndef __unused
+#define __unused  __attribute__((__unused__))
+#endif
+struct xlog_record {
+    const char *tag_str;
+    const char *fmt_str;
+    int prio;
+};
+
+LIBLOG_ABI_PUBLIC void __attribute__((weak)) __xlog_buf_printf(int bufid __unused, const struct xlog_record *xlog_record __unused, ...) {
+#ifndef FAKE_LOG_DEVICE
+    char prop[32]="0";
+    /* check property for diable all xlog */
+    __system_property_get("ro.disable.xlog",prop);
+    if (!strcmp(prop, "0"))
+#endif
+    {
+	va_list args;
+	va_start(args, xlog_record);
+	__android_log_vprint(xlog_record->prio, xlog_record->tag_str, xlog_record->fmt_str, args);
+    }
+}
+
diff --git a/libnetutils/Android.bp b/libnetutils/Android.bp
index 1d43775d6..8839fe118 100644
--- a/libnetutils/Android.bp
+++ b/libnetutils/Android.bp
@@ -17,7 +17,11 @@ cc_library_shared {
         "liblog",
     ],
 
-    cflags: ["-Werror"],
+    cflags: [
+        "-Werror",
+        "-DMTK_HARDWARE",
+        "-Wno-unused-parameter",
+    ],
 
     export_include_dirs: ["include"],
 }
diff --git a/libnetutils/ifc_utils.c b/libnetutils/ifc_utils.c
index a098d596e..85208d652 100644
--- a/libnetutils/ifc_utils.c
+++ b/libnetutils/ifc_utils.c
@@ -47,11 +47,19 @@
 
 #include "netutils/ifc.h"
 
+#ifdef MTK_HARDWARE
+#include <linux/un.h>
+#endif
+
 #if defined(__ANDROID__)
 /* SIOCKILLADDR is an Android extension. */
 #define SIOCKILLADDR 0x8939
 #endif
 
+#ifdef MTK_HARDWARE
+#define SIOCKILLSOCK 0x893a
+#endif
+
 static int ifc_ctl_sock = -1;
 static int ifc_ctl_sock6 = -1;
 static pthread_mutex_t ifc_sock_mutex = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;
@@ -725,3 +733,264 @@ ifc_configure(const char *ifname,
 
     return 0;
 }
+/* MTK */
+#ifdef MTK_HARDWARE
+
+int ifc_reset_connection_by_uid(int uid, int error)
+{
+#ifdef HAVE_ANDROID_OS
+
+    int tcp_ctl_sock;
+    int result = -1;
+    struct uid_err uid_e;
+
+    uid_e.appuid = uid;
+    uid_e.errorNum = error;
+
+    tcp_ctl_sock = socket(AF_INET, SOCK_STREAM, 0);
+    if (tcp_ctl_sock < 0) {
+        printerr("socket() failed: %s\n", strerror(errno));
+        return -1;
+    }
+
+    if(uid_e.appuid < 0){
+        ALOGE("ifc_reset_connection_by_uid, invalide uid: %d", uid_e.appuid);
+        close(tcp_ctl_sock);
+        return -1;
+    }
+
+    ALOGD("ifc_reset_connection_by_uid, appuid = %d, error = %d ",
+              uid_e.appuid, uid_e.errorNum);
+    result = ioctl(tcp_ctl_sock, SIOCKILLSOCK, &uid_e);
+    if(result < 0)
+        ALOGE("ifc_reset_connection_by_uid, result= %d, error =%s ", result, strerror(errno));
+
+        close(tcp_ctl_sock);
+    ALOGD("ifc_reset_connection_by_uid, result= %d ",result);
+    return result;
+#else
+    return 0;
+#endif
+}
+
+int ifc_enable_allmc(const char *ifname)
+{
+    int result;
+
+    ifc_init();
+    result = ifc_set_flags(ifname, IFF_ALLMULTI, 0);
+    ifc_close();
+
+    ALOGD("ifc_enable_allmc(%s) = %d", ifname, result);
+    return result;
+}
+
+int ifc_disable_allmc(const char *ifname)
+{
+    int result;
+
+    ifc_init();
+    result = ifc_set_flags(ifname, 0, IFF_ALLMULTI);
+    ifc_close();
+
+    ALOGD("ifc_disable_allmc(%s) = %d", ifname, result);
+    return result;
+}
+int ifc_is_up(const char *name, unsigned *isup)
+{
+    struct ifreq ifr;
+    ifc_init_ifr(name, &ifr);
+
+    if(ioctl(ifc_ctl_sock, SIOCGIFFLAGS, &ifr) < 0) {
+        printerr("ifc_is_up get flags error:%d(%s)", errno, strerror(errno));
+        return -1;
+    }
+    if(ifr.ifr_flags & IFF_UP)
+        *isup = 1;
+    else
+        *isup = 0;
+
+    return 0;
+}
+
+static int ifc_netd_sock_init(void)
+{
+    int ifc_netd_sock;
+    const int one = 1;
+    struct sockaddr_un netd_addr;
+
+        ifc_netd_sock = socket(AF_UNIX, SOCK_STREAM, 0);
+        if (ifc_netd_sock < 0) {
+            printerr("ifc_netd_sock_init: create socket failed");
+            return -1;
+        }
+
+        setsockopt(ifc_netd_sock, SOL_SOCKET, SO_REUSEADDR, &one, sizeof(one));
+        memset(&netd_addr, 0, sizeof(netd_addr));
+        netd_addr.sun_family = AF_UNIX;
+        strlcpy(netd_addr.sun_path, "/dev/socket/netd",
+            sizeof(netd_addr.sun_path));
+        if (TEMP_FAILURE_RETRY(connect(ifc_netd_sock,
+                     (const struct sockaddr*) &netd_addr,
+                     sizeof(netd_addr))) != 0) {
+            printerr("ifc_netd_sock_init: connect to netd failed, fd=%d, err: %d(%s)",
+                ifc_netd_sock, errno, strerror(errno));
+            close(ifc_netd_sock);
+            return -1;
+        }
+
+    if (DBG) printerr("ifc_netd_sock_init fd=%d", ifc_netd_sock);
+    return ifc_netd_sock;
+}
+
+/*do not call this function in netd*/
+int ifc_set_throttle(const char *ifname, int rxKbps, int txKbps)
+{
+    FILE* fnetd = NULL;
+    int ret = -1;
+    int seq = 1;
+    char rcv_buf[24];
+    int nread = 0;
+    int netd_sock = 0;
+
+    ALOGD("enter ifc_set_throttle: ifname = %s, rx = %d kbs, tx = %d kbs", ifname, rxKbps, txKbps);
+
+    netd_sock = ifc_netd_sock_init();
+    if(netd_sock <= 0)
+        goto exit;
+
+    // Send the request.
+    fnetd = fdopen(netd_sock, "r+");
+    if(fnetd == NULL){
+        ALOGE("open netd socket failed, err:%d(%s)", errno, strerror(errno));
+        goto exit;
+    }
+    if (fprintf(fnetd, "%d interface setthrottle %s %d %d", seq, ifname, rxKbps, txKbps) < 0) {
+        goto exit;
+    }
+    // literal NULL byte at end, required by FrameworkListener
+    if (fputc(0, fnetd) == EOF ||
+        fflush(fnetd) != 0) {
+        goto exit;
+    }
+    ret = 0;
+
+    //Todo: read the whole response from netd
+    nread = fread(rcv_buf, 1, 20, fnetd);
+    rcv_buf[23] = 0;
+    ALOGD("response: %s", rcv_buf);
+exit:
+    if (fnetd != NULL) {
+        fclose(fnetd);
+    }
+    return ret;
+}
+
+/*do not call this function in netd*/
+int ifc_set_fwmark_rule(const char *ifname, int mark, int add)
+{
+    FILE* fnetd = NULL;
+    int ret = -1;
+    int seq = 2;
+    char rcv_buf[24];
+      int nread = 0;
+      const char* op;
+    int netd_sock = 0;
+
+    if (add) {
+        op = "add";
+    } else {
+        op = "remove";
+    }
+    ALOGD("enter ifc_set_fwmark_rule: ifname = %s, mark = %d, op = %s", ifname, mark, op);
+
+    netd_sock = ifc_netd_sock_init();
+    if(netd_sock <= 0)
+        goto exit;
+
+    // Send the request.
+    fnetd = fdopen(netd_sock, "r+");
+    if(fnetd == NULL){
+        ALOGE("open netd socket failed, err:%d(%s)", errno, strerror(errno));
+        goto exit;
+    }
+    if (fprintf(fnetd, "%d network fwmark %s %s %d", seq, op, ifname, mark) < 0) {
+        goto exit;
+    }
+    // literal NULL byte at end, required by FrameworkListener
+    if (fputc(0, fnetd) == EOF ||
+        fflush(fnetd) != 0) {
+        goto exit;
+    }
+    ret = 0;
+
+    //Todo: read the whole response from netd
+    nread = fread(rcv_buf, 1, 20, fnetd);
+    rcv_buf[23] = 0;
+    ALOGD("ifc_set_fwmark_rule response: %s", rcv_buf);
+exit:
+    if (fnetd != NULL) {
+        fclose(fnetd);
+    }
+    return ret;
+}
+
+
+#define SIOCSTXQSTATE (SIOCDEVPRIVATE + 0)  //start/stop ccmni tx queue
+#define SIOCSCCMNICFG (SIOCDEVPRIVATE + 1)  //configure ccmni/md remapping
+
+int ifc_set_txq_state(const char *ifname, int state)
+{
+    struct ifreq ifr;
+    int ret, ctl_sock;
+
+    memset(&ifr, 0, sizeof(struct ifreq));
+    strncpy(ifr.ifr_name, ifname, IFNAMSIZ);
+    ifr.ifr_name[IFNAMSIZ - 1] = 0;
+    ifr.ifr_ifru.ifru_ivalue = state;
+
+    ctl_sock = socket(AF_INET, SOCK_DGRAM, 0);
+    if(ctl_sock < 0){
+        ALOGE("create ctl socket failed\n");
+        return -1;
+    }
+
+    ret = ioctl(ctl_sock, SIOCSTXQSTATE, &ifr);
+    if(ret < 0)
+        ALOGE("ifc_set_txq_state failed, err:%d(%s)\n", errno, strerror(errno));
+    else
+        ALOGI("ifc_set_txq_state as %d, ret: %d\n", state, ret);
+
+    close(ctl_sock);
+
+    return ret;
+}
+
+int ifc_ccmni_md_cfg(const char *ifname, int md_id)
+{
+    struct ifreq ifr;
+    int ret = 0;
+    int ctl_sock = 0;
+
+    ifc_init_ifr(ifname, &ifr);
+    ifr.ifr_ifru.ifru_ivalue = md_id;
+
+    ctl_sock = socket(AF_INET, SOCK_DGRAM, 0);
+    if(ctl_sock < 0){
+        printerr("ifc_ccmni_md_cfg: create ctl socket failed\n");
+        return -1;
+    }
+
+    if(ioctl(ctl_sock, SIOCSCCMNICFG, &ifr) < 0) {
+        printerr("ifc_ccmni_md_configure(ifname=%s, md_id=%d) error:%d(%s)", \
+            ifname, md_id, errno, strerror(errno));
+        ret = -1;
+    } else {
+        printerr("ifc_ccmni_md_configure(ifname=%s, md_id=%d) OK", ifname, md_id);
+    }
+
+    close(ctl_sock);
+    return ret;
+}
+
+#endif /* MTK_HARDWARE */
diff --git a/libnetutils/include/netutils/ifc.h b/libnetutils/include/netutils/ifc.h
index 3b272343d..116c5c074 100644
--- a/libnetutils/include/netutils/ifc.h
+++ b/libnetutils/include/netutils/ifc.h
@@ -61,6 +61,22 @@ extern int ifc_configure(const char *ifname, in_addr_t address,
 
 extern in_addr_t prefixLengthToIpv4Netmask(int prefix_length);
 
+/* MTK */
+#ifdef MTK_HARDWARE
+extern int ifc_is_up(const char *name, unsigned *isup);
+extern int ifc_enable_allmc(const char *name);
+extern int ifc_disable_allmc(const char *name);
+extern int ifc_reset_connection_by_uid(int uid, int error);
+extern int ifc_set_throttle(const char *ifname, int rxKbps, int txKbps);
+extern int ifc_set_fwmark_rule(const char *ifname, int mark, int add);
+extern int ifc_set_txq_state(const char *ifname, int state);
+extern int ifc_ccmni_md_cfg(const char *ifname, int md_id);
+struct uid_err {
+    int appuid;
+    int errorNum;
+};
+#endif /* MTK_HARDWARE */
+
 __END_DECLS
 
 #endif /* _NETUTILS_IFC_H_ */
diff --git a/libsuspend/Android.bp b/libsuspend/Android.bp
index 32f1e1ff8..21db90a13 100644
--- a/libsuspend/Android.bp
+++ b/libsuspend/Android.bp
@@ -9,6 +9,8 @@ cc_library {
 
     srcs: [
         "autosuspend.c",
+        "autosuspend_autosleep.c",
+        "autosuspend_earlysuspend.c",
         "autosuspend_wakeup_count.c",
     ],
     export_include_dirs: ["include"],
diff --git a/libsuspend/autosuspend.c b/libsuspend/autosuspend.c
index 96e1c10d0..54730c293 100644
--- a/libsuspend/autosuspend.c
+++ b/libsuspend/autosuspend.c
@@ -34,6 +34,19 @@ static int autosuspend_init(void)
         return 0;
     }
 
+    autosuspend_ops = autosuspend_earlysuspend_init();
+    if (autosuspend_ops) {
+        goto out;
+    }
+
+/* Remove autosleep so userspace can manager suspend/resume and keep stats */
+#if 0
+    autosuspend_ops = autosuspend_autosleep_init();
+    if (autosuspend_ops) {
+        goto out;
+    }
+#endif
+
     autosuspend_ops = autosuspend_wakeup_count_init();
     if (autosuspend_ops) {
         goto out;
diff --git a/libsuspend/autosuspend_autosleep.c b/libsuspend/autosuspend_autosleep.c
new file mode 100644
index 000000000..af8df1d9f
--- /dev/null
+++ b/libsuspend/autosuspend_autosleep.c
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "libsuspend"
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stddef.h>
+#include <string.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+#include <android/log.h>
+
+#include "autosuspend_ops.h"
+
+#define SYS_POWER_AUTOSLEEP "/sys/power/autosleep"
+
+static int autosleep_fd;
+static const char *sleep_state = "mem";
+static const char *on_state = "off";
+
+static int autosuspend_autosleep_enable(void)
+{
+    char buf[80];
+    int ret;
+
+    //ALOGV("autosuspend_autosleep_enable\n");
+
+    ret = TEMP_FAILURE_RETRY(write(autosleep_fd, sleep_state, strlen(sleep_state)));
+    if (ret < 0) {
+        strerror_r(errno, buf, sizeof(buf));
+        //ALOGE("Error writing to %s: %s\n", SYS_POWER_AUTOSLEEP, buf);
+        goto err;
+    }
+
+    //ALOGV("autosuspend_autosleep_enable done\n");
+
+    return 0;
+
+err:
+    return ret;
+}
+
+static int autosuspend_autosleep_disable(void)
+{
+    char buf[80];
+    int ret;
+
+    //ALOGV("autosuspend_autosleep_disable\n");
+
+    ret = TEMP_FAILURE_RETRY(write(autosleep_fd, on_state, strlen(on_state)));
+    if (ret < 0) {
+        strerror_r(errno, buf, sizeof(buf));
+        //ALOGE("Error writing to %s: %s\n", SYS_POWER_AUTOSLEEP, buf);
+        goto err;
+    }
+
+    //ALOGV("autosuspend_autosleep_disable done\n");
+
+    return 0;
+
+err:
+    return ret;
+}
+
+struct autosuspend_ops autosuspend_autosleep_ops = {
+        .enable = autosuspend_autosleep_enable,
+        .disable = autosuspend_autosleep_disable,
+};
+
+struct autosuspend_ops *autosuspend_autosleep_init(void)
+{
+    char buf[80];
+
+    autosleep_fd = TEMP_FAILURE_RETRY(open(SYS_POWER_AUTOSLEEP, O_WRONLY));
+    if (autosleep_fd < 0) {
+        strerror_r(errno, buf, sizeof(buf));
+        //ALOGE("Error opening %s: %s\n", SYS_POWER_AUTOSLEEP, buf);
+        return NULL;
+    }
+
+    //ALOGI("Selected autosleep\n");
+
+    autosuspend_autosleep_disable();
+
+    return &autosuspend_autosleep_ops;
+}
diff --git a/libsuspend/autosuspend_earlysuspend.c b/libsuspend/autosuspend_earlysuspend.c
new file mode 100644
index 000000000..d3367de56
--- /dev/null
+++ b/libsuspend/autosuspend_earlysuspend.c
@@ -0,0 +1,220 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "libsuspend"
+
+#include <errno.h>
+#include <fcntl.h>
+#include <pthread.h>
+#include <stdbool.h>
+#include <stddef.h>
+#include <string.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+#include <android/log.h>
+
+#include "autosuspend_ops.h"
+
+#define EARLYSUSPEND_SYS_POWER_STATE "/sys/power/state"
+#define EARLYSUSPEND_WAIT_FOR_FB_SLEEP "/sys/power/wait_for_fb_sleep"
+#define EARLYSUSPEND_WAIT_FOR_FB_WAKE "/sys/power/wait_for_fb_wake"
+
+static int sPowerStatefd;
+static const char *pwr_state_mem = "mem";
+static const char *pwr_state_on = "on";
+static pthread_t earlysuspend_thread;
+static pthread_mutex_t earlysuspend_mutex = PTHREAD_MUTEX_INITIALIZER;
+static pthread_cond_t earlysuspend_cond = PTHREAD_COND_INITIALIZER;
+static bool wait_for_earlysuspend;
+static enum {
+    EARLYSUSPEND_ON,
+    EARLYSUSPEND_MEM,
+} earlysuspend_state = EARLYSUSPEND_ON;
+
+int wait_for_fb_wake(void)
+{
+    int err = 0;
+    char buf;
+    int fd = TEMP_FAILURE_RETRY(open(EARLYSUSPEND_WAIT_FOR_FB_WAKE, O_RDONLY, 0));
+    // if the file doesn't exist, the error will be caught in read() below
+    err = TEMP_FAILURE_RETRY(read(fd, &buf, 1));
+    //ALOGE_IF(err < 0,
+            //"*** ANDROID_WAIT_FOR_FB_WAKE failed (%s)", strerror(errno));
+    close(fd);
+    return err < 0 ? err : 0;
+}
+
+static int wait_for_fb_sleep(void)
+{
+    int err = 0;
+    char buf;
+    int fd = TEMP_FAILURE_RETRY(open(EARLYSUSPEND_WAIT_FOR_FB_SLEEP, O_RDONLY, 0));
+    // if the file doesn't exist, the error will be caught in read() below
+    err = TEMP_FAILURE_RETRY(read(fd, &buf, 1));
+    //ALOGE_IF(err < 0,
+            //"*** ANDROID_WAIT_FOR_FB_SLEEP failed (%s)", strerror(errno));
+    close(fd);
+    return err < 0 ? err : 0;
+}
+
+static void *earlysuspend_thread_func(void __unused *arg)
+{
+    while (1) {
+        if (wait_for_fb_sleep()) {
+            //ALOGE("Failed reading wait_for_fb_sleep, exiting earlysuspend thread\n");
+            return NULL;
+        }
+        pthread_mutex_lock(&earlysuspend_mutex);
+        earlysuspend_state = EARLYSUSPEND_MEM;
+        pthread_cond_signal(&earlysuspend_cond);
+        pthread_mutex_unlock(&earlysuspend_mutex);
+
+        if (wait_for_fb_wake()) {
+            //ALOGE("Failed reading wait_for_fb_wake, exiting earlysuspend thread\n");
+            return NULL;
+        }
+        pthread_mutex_lock(&earlysuspend_mutex);
+        earlysuspend_state = EARLYSUSPEND_ON;
+        pthread_cond_signal(&earlysuspend_cond);
+        pthread_mutex_unlock(&earlysuspend_mutex);
+    }
+}
+static int autosuspend_earlysuspend_enable(void)
+{
+    char buf[80];
+    int ret;
+
+    //ALOGV("autosuspend_earlysuspend_enable\n");
+
+    ret = write(sPowerStatefd, pwr_state_mem, strlen(pwr_state_mem));
+
+    if (ret < 0) {
+        strerror_r(errno, buf, sizeof(buf));
+        //ALOGE("Error writing to %s: %s\n", EARLYSUSPEND_SYS_POWER_STATE, buf);
+        goto err;
+    }
+
+    if (wait_for_earlysuspend) {
+        pthread_mutex_lock(&earlysuspend_mutex);
+        while (earlysuspend_state != EARLYSUSPEND_MEM) {
+            pthread_cond_wait(&earlysuspend_cond, &earlysuspend_mutex);
+        }
+        pthread_mutex_unlock(&earlysuspend_mutex);
+    }
+
+    //ALOGV("autosuspend_earlysuspend_enable done\n");
+
+    return 0;
+
+err:
+    return ret;
+}
+
+static int autosuspend_earlysuspend_disable(void)
+{
+    char buf[80];
+    int ret;
+
+    //ALOGV("autosuspend_earlysuspend_disable\n");
+
+    ret = TEMP_FAILURE_RETRY(write(sPowerStatefd, pwr_state_on, strlen(pwr_state_on)));
+    if (ret < 0) {
+        strerror_r(errno, buf, sizeof(buf));
+        //ALOGE("Error writing to %s: %s\n", EARLYSUSPEND_SYS_POWER_STATE, buf);
+        goto err;
+    }
+
+    if (wait_for_earlysuspend) {
+        pthread_mutex_lock(&earlysuspend_mutex);
+        while (earlysuspend_state != EARLYSUSPEND_ON) {
+            pthread_cond_wait(&earlysuspend_cond, &earlysuspend_mutex);
+        }
+        pthread_mutex_unlock(&earlysuspend_mutex);
+    }
+
+    //ALOGV("autosuspend_earlysuspend_disable done\n");
+
+    return 0;
+
+err:
+    return ret;
+}
+
+struct autosuspend_ops autosuspend_earlysuspend_ops = {
+        .enable = autosuspend_earlysuspend_enable,
+        .disable = autosuspend_earlysuspend_disable,
+};
+
+void start_earlysuspend_thread(void)
+{
+    char buf[80];
+    int ret;
+
+    ret = access(EARLYSUSPEND_WAIT_FOR_FB_SLEEP, F_OK);
+    if (ret < 0) {
+        return;
+    }
+
+    ret = access(EARLYSUSPEND_WAIT_FOR_FB_WAKE, F_OK);
+    if (ret < 0) {
+        return;
+    }
+
+    wait_for_fb_wake();
+
+    //ALOGI("Starting early suspend unblocker thread\n");
+    ret = pthread_create(&earlysuspend_thread, NULL, earlysuspend_thread_func, NULL);
+    if (ret) {
+        strerror_r(errno, buf, sizeof(buf));
+        //ALOGE("Error creating thread: %s\n", buf);
+        return;
+    }
+
+    wait_for_earlysuspend = true;
+}
+
+struct autosuspend_ops *autosuspend_earlysuspend_init(void)
+{
+    char buf[80];
+    int ret;
+
+    sPowerStatefd = TEMP_FAILURE_RETRY(open(EARLYSUSPEND_SYS_POWER_STATE, O_RDWR));
+
+    if (sPowerStatefd < 0) {
+        strerror_r(errno, buf, sizeof(buf));
+        //ALOGW("Error opening %s: %s\n", EARLYSUSPEND_SYS_POWER_STATE, buf);
+        return NULL;
+    }
+
+    ret = TEMP_FAILURE_RETRY(write(sPowerStatefd, "on", 2));
+    if (ret < 0) {
+        strerror_r(errno, buf, sizeof(buf));
+        //ALOGW("Error writing 'on' to %s: %s\n", EARLYSUSPEND_SYS_POWER_STATE, buf);
+        goto err_write;
+    }
+
+    //ALOGI("Selected early suspend\n");
+
+    start_earlysuspend_thread();
+
+    return &autosuspend_earlysuspend_ops;
+
+err_write:
+    close(sPowerStatefd);
+    return NULL;
+}
-- 
2.17.1

