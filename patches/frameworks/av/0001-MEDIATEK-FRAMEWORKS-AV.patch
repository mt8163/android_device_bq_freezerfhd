---
 camera/include/camera/MtkCamera.h             | 333 +++++++++
 camera/include/camera/MtkCameraParameters.h   | 651 ++++++++++++++++++
 media/libaudiohal/Android.mk                  |   4 +
 media/libaudiohal/DeviceHalLocal.cpp          |  17 +
 media/libaudiohal/DeviceHalLocal.h            |   4 +-
 media/libmedia/MediaProfiles.cpp              |  53 +-
 media/libmedia/include/media/MediaProfiles.h  |  50 +-
 media/libmedia/include/media/mediarecorder.h  |  13 +-
 .../StagefrightRecorder.cpp                   |   2 +-
 media/libstagefright/ACodec.cpp               |  64 +-
 media/libstagefright/Android.bp               |   9 +-
 media/libstagefright/CameraSource.cpp         |  20 +
 media/libstagefright/MPEG4Writer.cpp          |   6 +
 .../libstagefright/colorconversion/Android.bp |   7 +-
 .../colorconversion/ColorConverter.cpp        | 177 +++++
 .../colorconversion/inc/DpBlitStream.h        | 209 ++++++
 .../colorconversion/inc/DpConfig.h            |  24 +
 .../colorconversion/inc/DpDataType.h          | 631 +++++++++++++++++
 media/libstagefright/foundation/Android.bp    |   1 +
 .../foundation/MediaBufferGroup.cpp           |  10 +
 .../include/media/stagefright/ACodec.h        |   3 +
 .../include/media/stagefright/CameraSource.h  |   2 +-
 .../media/stagefright/ColorConverter.h        |   6 +
 .../media/stagefright/MediaBufferGroup.h      |  11 +
 .../include/media/stagefright/MediaCodec.h    |  11 +
 media/libstagefright/omx/Android.bp           |  18 +
 media/libstagefright/omx/OMXNodeInstance.cpp  |  45 ++
 media/libstagefright/omx/OMXUtils.cpp         |   4 +-
 .../media/stagefright/omx/OMXNodeInstance.h   |   5 +
 services/audioflinger/Android.mk              |   4 +
 services/audioflinger/Threads.cpp             |   2 +
 services/camera/libcameraservice/Android.mk   |  12 +-
 .../camera/libcameraservice/api1/CamUtils.h   |  64 ++
 .../libcameraservice/api1/CameraClient.cpp    | 370 +++++++++-
 .../libcameraservice/api1/CameraClient.h      |  25 +
 .../camera/libcameraservice/api1/Format.h     | 190 +++++
 .../camera/libcameraservice/api1/IBuffer.h    | 118 ++++
 .../libcameraservice/api1/StreamImgBuf.cpp    | 244 +++++++
 .../libcameraservice/api1/StreamImgBuf.h      | 161 +++++
 39 files changed, 3567 insertions(+), 13 deletions(-)
 create mode 100644 camera/include/camera/MtkCamera.h
 create mode 100644 camera/include/camera/MtkCameraParameters.h
 create mode 100644 media/libstagefright/colorconversion/inc/DpBlitStream.h
 create mode 100644 media/libstagefright/colorconversion/inc/DpConfig.h
 create mode 100644 media/libstagefright/colorconversion/inc/DpDataType.h
 create mode 100644 services/camera/libcameraservice/api1/CamUtils.h
 create mode 100644 services/camera/libcameraservice/api1/Format.h
 create mode 100644 services/camera/libcameraservice/api1/IBuffer.h
 create mode 100644 services/camera/libcameraservice/api1/StreamImgBuf.cpp
 create mode 100644 services/camera/libcameraservice/api1/StreamImgBuf.h

diff --git a/camera/include/camera/MtkCamera.h b/camera/include/camera/MtkCamera.h
new file mode 100644
index 0000000000..ec7dabfe0d
--- /dev/null
+++ b/camera/include/camera/MtkCamera.h
@@ -0,0 +1,333 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _MTK_FRAMEWORKS_AV_INCLUDE_CAMERA_MTKCAMERA_H_
+#define _MTK_FRAMEWORKS_AV_INCLUDE_CAMERA_MTKCAMERA_H_
+
+#include <binder/IMemory.h>
+
+namespace android {
+
+// extended msgType in notifyCallback and dataCallback functions
+enum {
+    MTK_CAMERA_MSG_EXT_NOTIFY       = 0x40000000,
+    MTK_CAMERA_MSG_EXT_DATA         = 0x80000000,
+};
+
+// extended notify message related to MTK_CAMERA_MSG_EXT_NOTIFY used in notifyCallback functions
+enum {
+    //
+    //  Smile Detection
+    MTK_CAMERA_MSG_EXT_NOTIFY_SMILE_DETECT      = 0x00000001,
+    //
+    //  Auto Scene Detection
+    MTK_CAMERA_MSG_EXT_NOTIFY_ASD               = 0x00000002,
+    //
+    //  Multi Angle View
+    MTK_CAMERA_MSG_EXT_NOTIFY_MAV               = 0x00000003,
+    //
+    // Burst Shutter Callback
+    //  ext2: count-down shutter number; 0: the last one shutter.
+    MTK_CAMERA_MSG_EXT_NOTIFY_BURST_SHUTTER     = 0x00000004,
+    //
+    // Continuous Shutter Callback
+    //  ext2: current continuous shutter number.
+    MTK_CAMERA_MSG_EXT_NOTIFY_CONTINUOUS_SHUTTER= 0x00000005,
+    //
+    // Continuous EndCallback
+    MTK_CAMERA_MSG_EXT_NOTIFY_CONTINUOUS_END    = 0x00000006,
+
+    // ZSD preview done
+    MTK_CAMERA_MSG_EXT_NOTIFY_ZSD_PREVIEW_DONE = 0x00000007,
+    //
+    // Capture done (disable CAMERA_MSG_SHUTTER / CAMERA_MSG_COMPRESSED_IMAGE)
+    MTK_CAMERA_MSG_EXT_NOTIFY_CAPTURE_DONE      = 0x00000010,
+    //
+    // Shutter Callback (not disable CAMERA_MSG_SHUTTER)
+    //  ext2: 1: CameraService will play shutter sound.
+    MTK_CAMERA_MSG_EXT_NOTIFY_SHUTTER           = 0x00000011,
+    //
+    // for EM preview raw dump error notify
+    MTK_CAMERA_MSG_EXT_NOTIFY_RAW_DUMP_STOPPED  = 0x00000012,
+    //
+    // Gesture Detection
+    MTK_CAMERA_MSG_EXT_NOTIFY_GESTURE_DETECT  = 0x00000013,
+    //
+    // Stereo Feature: warning message
+    MTK_CAMERA_MSG_EXT_NOTIFY_STEREO_WARNING    = 0x00000014,
+    //
+    // Stereo Feature: distance value
+    MTK_CAMERA_MSG_EXT_NOTIFY_STEREO_DISTANCE   = 0x00000015,
+    //
+    // Result & Static metadata
+    MTK_CAMERA_MSG_EXT_NOTIFY_METADATA_DONE   = 0x00000016,
+    //
+    // ZSD capture early callback
+    MTK_CAMERA_MSG_EXT_NOTIFY_P2DONE            = 0x00000017
+};
+
+// extended data message related to MTK_CAMERA_MSG_EXT_DATA used in dataCallback functions
+// extended data header is located at the top of dataPrt in dataCallback functions
+//  DATA: Header + Params
+enum {
+    //
+    // Auto Panorama
+    //  Params:
+    //      int[0]: 0:mAUTORAMAMVCallback, 1:mAUTORAMACallback
+    //      int[1~]:depends on
+    //
+    MTK_CAMERA_MSG_EXT_DATA_AUTORAMA            = 0x00000001,
+    //
+    // AF Window Results
+    MTK_CAMERA_MSG_EXT_DATA_AF                    = 0x00000002,
+    //
+    // Burst Shot (EV Shot)
+    //      int[0]: the total shut count.
+    //      int[1]: count-down shut number; 0: the last one shut.
+    MTK_CAMERA_MSG_EXT_DATA_BURST_SHOT          = 0x00000003,
+    //
+    //    Continuous Shot
+    //        int[0]: current continuous shut number.
+    MTK_CAMERA_MSG_EXT_DATA_CONTINUOUS_SHOT     = 0x00000004,
+
+
+    MTK_CAMERA_MSG_EXT_DATA_OT                  = 0x00000005,
+
+    //  Facebeauty Shot
+    //      int[0]: data type. 0:original image.
+    MTK_CAMERA_MSG_EXT_DATA_FACEBEAUTY          = 0x00000006,
+    //
+    //  MAV Shot
+    //      int[0]: data type. 0:original image.
+    MTK_CAMERA_MSG_EXT_DATA_MAV                 = 0x00000007,
+    //
+    //  HDR Shot
+    //      int[0]: data type. 0:0EV image.
+    MTK_CAMERA_MSG_EXT_DATA_HDR                 = 0x00000008,
+
+    //
+    // Motion Track
+    //  Params:
+    //      int[0]: 0: frame EIS, 1: captured image, 2: blended image, 3: intermediate data
+    //      int[1~]:depends on
+    //
+    MTK_CAMERA_MSG_EXT_DATA_MOTIONTRACK         = 0x00000009,
+
+    //
+    //  Compressed Image (not disable CAMERA_MSG_COMPRESSED_IMAGE)
+    //      int[0]: current shut index; 0: the first one shut.
+    MTK_CAMERA_MSG_EXT_DATA_COMPRESSED_IMAGE    = 0x00000010,
+
+    //
+    //  Stereo Shot
+    //      int[0]: data type.
+    MTK_CAMERA_MSG_EXT_DATA_JPS                 = 0x00000011,
+
+    //
+    //  Stereo Debug Data
+    //      int[0]: data type.
+    MTK_CAMERA_MSG_EXT_DATA_STEREO_DBG          = 0x00000012,
+
+    //
+    // raw16
+    MTK_CAMERA_MSG_EXT_DATA_RAW16               = 0x00000013,
+
+    //
+    // Stereo Shot
+    //      int[0]: data type.
+    MTK_CAMERA_MSG_EXT_DATA_DEPTHMAP            = 0x00000014,
+
+    //
+    // Stereo Shot
+    //      int[0]: data type.
+    MTK_CAMERA_MSG_EXT_DATA_STEREO_CLEAR_IMAGE  = 0x00000015,
+
+};
+// extended data message related to MTK_CAMERA_MSG_EXT_DATA used in dataCallback functions
+// extended data header is located at the top of dataPrt in dataCallback functions
+//  DATA: Header + Params
+enum {
+    //
+    // static & result metadata for raw16
+    MTK_CAMERA_MSG_EXT_METADATA_RAW16            = 0x00000001,
+};
+
+//  MTK-extended camera message data helper.
+//  DATA: Header + Params
+class MtkCamMsgExtDataHelper
+{
+public:
+    //  The header type of MTK-extended camera message data.
+    struct DataHeader {
+        uint32_t        extMsgType;
+    };
+
+public:
+    MtkCamMsgExtDataHelper();
+    ~MtkCamMsgExtDataHelper();
+    bool            init(const sp<IMemory>& dataPtr);
+    bool            uninit();
+    bool            create(size_t const extParamSize, uint32_t const u4ExtMsgType);
+    bool            destroy();
+
+    uint8_t*                        getExtParamBase() const;
+    size_t                          getExtParamSize() const;
+    ssize_t                         getExtParamOffset() const;
+    inline uint32_t                 getExtMsgType() const { return mExtDataHdr.extMsgType; }
+    inline DataHeader const&        getExtDataHeader() const { return mExtDataHdr; }
+    inline sp<IMemory>const&        getData() const { return mspData; }
+    inline sp<IMemoryHeap>const&    getHeap() const { return mspHeap; }
+
+protected:
+    bool            mIsValid;
+    sp<IMemory>     mspData;
+    sp<IMemoryHeap> mspHeap;
+    ssize_t         mDataOffset;
+    size_t          mDataSize;
+    DataHeader      mExtDataHdr;
+};
+
+
+// cmdType in sendCommand functions
+enum {
+    CAMERA_CMD_MTK_DEFINE_START     = 0x10000000,
+    CAMERA_CMD_DO_PANORAMA,
+    CAMERA_CMD_CANCEL_PANORAMA,
+    CAMERA_CMD_START_SD_PREVIEW,            //(Smile Detection)
+    CAMERA_CMD_CANCEL_SD_PREVIEW,           //(Smile Detection)
+    CAMERA_CMD_START_OT,
+    CAMERA_CMD_STOP_OT,
+    CAMERA_CMD_START_MAV,
+    CAMERA_CMD_STOP_MAV,
+    CAMERA_CMD_START_AUTORAMA,
+    CAMERA_CMD_STOP_AUTORAMA,
+    CAMERA_CMD_GET_MEM_INFO,                //For Video to get PMEM buffer info
+    CAMERA_CMD_GET_REC_BUF_INFO,
+    CAMERA_CMD_CANCEL_CSHOT,
+    CAMERA_CMD_SET_CSHOT_SPEED,
+    CAMERA_CMD_START_3DSHOT,
+    CAMERA_CMD_STOP_3DSHOT,
+    CAMERA_CMD_START_MOTIONTRACK,
+    CAMERA_CMD_STOP_MOTIONTRACK,
+    CAMERA_CMD_START_CLONECAMERA,
+    CAMERA_CMD_SHOT_CLONECAMERA,
+    CAMERA_CMD_STOP_CLONECAMERA,
+    CAMERA_CMD_START_GD_PREVIEW,            //(Gesture Detection)
+    CAMERA_CMD_CANCEL_GD_PREVIEW,           //(Gesture Detection)
+
+    // For SDK Heartrate
+    CAMERA_CMD_START_HR_PREVIEW,            //(Heartrate Detection)
+    CAMERA_CMD_STOP_HR_PREVIEW,             //(Heartrate Detection)
+    CAMERA_CMD_SETCB_HR_PREVIEW,            //(Heartrate Detection)
+    CAMERA_CMD_SETUSER_HR_PREVIEW,          //(Heartrate Detection)
+    CAMERA_CMD_SETMODE_HR_PREVIEW,          //(Heartrate Detection)
+    CAMERA_CMD_CHECKPARA_HR_PREVIEW,        //(Heartrate Detection)
+
+    // For Main face informatin
+    CAMERA_CMD_SET_MAIN_FACE_COORDINATE,
+    CAMERA_CMD_CANCEL_MAIN_FACE,
+    //
+    CAMERA_CMD_ENABLE_RAW16_CALLBACK,
+};
+
+/*
+ * For Video to get PMEM buffer info
+ *
+ * Command: CAMERA_CMD_GET_MEM_INFO
+ */
+struct CameraMemInfo {
+    enum { eTYPE_PMEM = 0 };
+    uint32_t    u4Type;
+    uint32_t    u4VABase;
+    uint32_t    u4PABase;
+    uint32_t    u4MemSize;
+    uint32_t    u4MemCount;
+};
+
+
+/*
+ *  set camera fatal errors enum
+ *
+ */
+enum {
+    CAMERA_ERROR_NO_MEMORY   = 1000,
+    CAMERA_ERROR_RESET       = 1001,
+    CAMERA_ERROR_CALI_FLASH  = 1002,
+};
+
+/*
+ * For Video to get buffer info
+ *
+ * Command: CAMERA_CMD_GET_REC_BUF_INFO
+ */
+struct CameraRecBufInfo {
+    int32_t     i4MemId;
+    uint32_t    u4VirAddr;
+    uint32_t    u4Size;
+};
+
+
+/*
+ * For Video to set setting
+ *
+ * Command: CAMERA_CMD_GET_REC_BUF_INFO
+ */
+struct CameraRecSetting {
+    int32_t     mi4BufSecu; //security
+    int32_t     mi4BufCohe; //coherent
+};
+
+
+}; // namespace android
+
+#endif  //_MTK_FRAMEWORKS_AV_INCLUDE_CAMERA_MTKCAMERA_H_
diff --git a/camera/include/camera/MtkCameraParameters.h b/camera/include/camera/MtkCameraParameters.h
new file mode 100644
index 0000000000..42f0a3febc
--- /dev/null
+++ b/camera/include/camera/MtkCameraParameters.h
@@ -0,0 +1,651 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _MTK_HARDWARE_MTKCAM_INCLUDE_MTKCAM_UTILS_FWK_MTKCAMERAPARAMETERS_H
+#define _MTK_HARDWARE_MTKCAM_INCLUDE_MTKCAM_UTILS_FWK_MTKCAMERAPARAMETERS_H
+
+#include <camera/CameraParameters.h>
+
+namespace android {
+
+/**
+ * @class      MtkCameraParameters
+ * @brief      MTK-proprietary camera parameters.
+ * @details    This class is derived from CameraParameters and defines MTK-proprietary camera parameters.
+ */
+class MtkCameraParameters : public CameraParameters
+{
+public:
+    MtkCameraParameters() : CameraParameters() {}
+    MtkCameraParameters(const String8 &params) { unflatten(params); }
+    ~MtkCameraParameters()  {}
+
+    MtkCameraParameters& operator=(CameraParameters const& params)
+    {
+        unflatten(params.flatten());
+        return  (*this);
+    }
+
+    void setPreviewSize(int width, int height);
+    void getPreviewSize(int *width, int *height) const;
+    //
+    /**************************************************************************
+     * @brief Query the image format constant.
+     *
+     * @details Given a MtkCameraParameters::PIXEL_FORMAT_xxx, return its
+     * corresponding image format constant.
+     *
+     * @note
+     *
+     * @param[in] szPixelFormat: A null-terminated string for pixel format (i.e.
+     * MtkCameraParameters::PIXEL_FORMAT_xxx)
+     *
+     * @return its corresponding image format.
+     *
+     **************************************************************************/
+    static int queryImageFormat(String8 const& s8PixelFormat);
+    static int queryImageFormat(char const* szPixelFormat);
+
+//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+//  App Mode.
+//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+    static const char PROPERTY_KEY_CLIENT_APPMODE[];
+    //
+    static const char APP_MODE_NAME_DEFAULT[];
+    static const char APP_MODE_NAME_MTK_ENG[];
+    static const char APP_MODE_NAME_MTK_ATV[];
+    static const char APP_MODE_NAME_MTK_STEREO[];
+    static const char APP_MODE_NAME_MTK_VT[];
+    static const char APP_MODE_NAME_MTK_PHOTO[];
+    static const char APP_MODE_NAME_MTK_VIDEO[];
+    static const char APP_MODE_NAME_MTK_ZSD[];
+    //
+//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+//  Scene Mode
+//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+    static const char SCENE_MODE_NORMAL[];
+    //
+//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+//  Face Beauty
+//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+    static const char KEY_FB_SMOOTH_LEVEL[];
+    static const char KEY_FB_SMOOTH_LEVEL_MIN[];
+    static const char KEY_FB_SMOOTH_LEVEL_MAX[];
+    static const char KEY_FB_SMOOTH_LEVEL_Default[];
+    //
+    static const char KEY_FB_SKIN_COLOR[];
+    static const char KEY_FB_SKIN_COLOR_MIN[];
+    static const char KEY_FB_SKIN_COLOR_MAX[];
+    static const char KEY_FB_SKIN_COLOR_Default[];
+    //
+    static const char KEY_FB_SHARP[];
+    static const char KEY_FB_SHARP_MIN[];
+    static const char KEY_FB_SHARP_MAX[];
+    //
+    static const char KEY_FB_ENLARGE_EYE[];
+    static const char KEY_FB_ENLARGE_EYE_MIN[];
+    static const char KEY_FB_ENLARGE_EYE_MAX[];
+    //
+    static const char KEY_FB_SLIM_FACE[];
+    static const char KEY_FB_SLIM_FACE_MIN[];
+    static const char KEY_FB_SLIM_FACE_MAX[];
+    //
+    static const char KEY_FB_EXTREME_BEAUTY[];
+    //
+    static const char KEY_FB_TOUCH_POS[];
+    //
+    static const char KEY_FB_FACE_POS[];
+    //
+    static const char KEY_FACE_BEAUTY[];
+    //
+    static const char KEY_FB_EXTREME_SUPPORTED[];
+    //
+    static const char KEY_FEATURE_MAX_FPS[];
+    //
+    static const char KEY_VIDEO_FACE_BEAUTY_SUPPORTED[];
+    //
+//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+//
+//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+    static const char KEY_EXPOSURE[];
+    static const char KEY_EXPOSURE_METER[];
+    static const char KEY_ISO_SPEED[];
+    static const char KEY_AE_MODE[];
+    static const char KEY_FOCUS_METER[];
+    static const char KEY_EDGE[];
+    static const char KEY_HUE[];
+    static const char KEY_SATURATION[];
+    static const char KEY_BRIGHTNESS[];
+    static const char KEY_CONTRAST[];
+    static const char KEY_ZSD_MODE[];
+    static const char KEY_SUPPORTED_ZSD_MODE[];
+    static const char KEY_AWB2PASS[];
+    static const char KEY_AF_LAMP_MODE [];
+    static const char KEY_SNAPSHOT_PICTURE_FLIP[];
+    static const char FLASH_MODE_TORCH1[];
+    static const char FLASH_MODE_TORCH2[];
+
+    static const char KEY_STEREO_3D_PREVIEW_SIZE[];
+    static const char KEY_STEREO_3D_PICTURE_SIZE[];
+    static const char KEY_STEREO_3D_TYPE [];
+    static const char KEY_STEREO_3D_MODE [];
+    static const char KEY_STEREO_3D_IMAGE_FORMAT [];
+    //
+    static const char KEY_FPS_MODE[];       // normal,fix
+    //
+    static const char KEY_FOCUS_DRAW[];     // 0,1
+    //
+    static const char KEY_CAPTURE_MODE[];   // normal,bestshot,evbracketshot,burstshot,smileshot,panoramashot
+    static const char KEY_SUPPORTED_CAPTURE_MODES[];
+    static const char KEY_CAPTURE_PATH[];
+    static const char KEY_BURST_SHOT_NUM[];
+    //
+    static const char KEY_MATV_PREVIEW_DELAY[];
+    //
+    static const char KEY_PANORAMA_IDX[];
+    static const char KEY_PANORAMA_DIR[];   // right,left,top,bottom
+    //
+    static const char KEY_SENSOR_DEV[];    // main,sub,atv
+    static const char KEY_SUPPORTED_SENSOR_DEVS[];
+
+    // Values for KEY_EXPOSURE
+    static const char EXPOSURE_METER_SPOT[];
+    static const char EXPOSURE_METER_CENTER[];
+    static const char EXPOSURE_METER_AVERAGE[];
+
+    // Valeus for KEY_ISO_SPEED
+    static const char ISO_SPEED_AUTO[];
+    static const char ISO_SPEED_100[];
+    static const char ISO_SPEED_200[];
+    static const char ISO_SPEED_400[];
+    static const char ISO_SPEED_800[];
+    static const char ISO_SPEED_1600[];
+
+    // Values for KEY_FOCUS_METER
+    static const char FOCUS_METER_SPOT[];
+    static const char FOCUS_METER_MULTI[];
+
+    static const char KEY_CAMERA_MODE[];
+    // Values for KEY_CAMERA_MODE
+    static const int CAMERA_MODE_NORMAL;
+    static const int CAMERA_MODE_MTK_PRV;
+    static const int CAMERA_MODE_MTK_VDO;
+    static const int CAMERA_MODE_MTK_VT;
+
+    // Values for KEY_FPS_MODE
+    static const int FPS_MODE_NORMAL;
+    static const int FPS_MODE_FIX;
+
+    // Values for KEY_CAPTURE_MODE
+    static const char CAPTURE_MODE_PANORAMA_SHOT[];
+    static const char CAPTURE_MODE_BURST_SHOT[];
+    static const char CAPTURE_MODE_NORMAL[];
+    static const char CAPTURE_MODE_BEST_SHOT[];
+    static const char CAPTURE_MODE_EV_BRACKET_SHOT[];
+    static const char CAPTURE_MODE_SMILE_SHOT[];
+    static const char CAPTURE_MODE_AUTO_PANORAMA_SHOT[];
+    static const char CAPTURE_MODE_MOTION_TRACK_SHOT[];
+    static const char CAPTURE_MODE_MAV_SHOT[];
+    static const char CAPTURE_MODE_HDR_SHOT[];
+    static const char CAPTURE_MODE_ASD_SHOT[];
+    static const char CAPTURE_MODE_ZSD_SHOT[];
+    static const char CAPTURE_MODE_PANO_3D[];
+    static const char CAPTURE_MODE_SINGLE_3D[];
+    static const char CAPTURE_MODE_FACE_BEAUTY[];
+    static const char CAPTURE_MODE_CONTINUOUS_SHOT[];
+    static const char CAPTURE_MODE_MULTI_MOTION[];
+    static const char CAPTURE_MODE_GESTURE_SHOT[];
+
+    // Values for KEY_PANORAMA_DIR
+    static const char PANORAMA_DIR_RIGHT[];
+    static const char PANORAMA_DIR_LEFT[];
+    static const char PANORAMA_DIR_TOP[];
+    static const char PANORAMA_DIR_DOWN[];
+    //
+    static const int ENABLE;
+    static const int DISABLE;
+
+    // Values for KEY_EDGE, KEY_HUE, KEY_SATURATION, KEY_BRIGHTNESS, KEY_CONTRAST
+    static const char HIGH[];
+    static const char MIDDLE[];
+    static const char LOW[];
+
+    // Preview Internal Format.
+    static const char KEY_PREVIEW_INT_FORMAT[];
+
+    // Pixel color formats for KEY_PREVIEW_FORMAT, KEY_PICTURE_FORMAT,
+    // and KEY_VIDEO_FRAME_FORMAT
+    static const char PIXEL_FORMAT_YUV420I[]; // I420
+
+    /**
+     * @var PIXEL_FORMAT_YV12_GPU
+     *
+     * GPU YUV format:
+     *
+     * YV12 is a 4:2:0 YCrCb planar format comprised of a WxH Y plane followed
+     * by (W/2) x (H/2) Cr and Cb planes.
+     *
+     * This format assumes
+     * - an even width
+     * - an even height
+     * - a vertical stride equal to the height
+     * - a horizontal stride multiple of 32/16/16 pixels for y/cr/cb respectively
+     *   i.e.
+     *   y_stride = ALIGN(width, 32)
+     *   c_stride = y_stride / 2
+     *
+     *   y_size = y_stride * height
+     *   c_size = c_stride * height / 2
+     *   size = y_size + c_size * 2
+     *   cr_offset = y_size
+     *   cb_offset = y_size + c_size
+     *
+     *   for example:
+     *      width/height = 176x144
+     *      y stride     = 192x144
+     *      cr stride    = 96x72
+     *      cb stride    = 96x72
+     *
+     */
+    static const char PIXEL_FORMAT_YV12_GPU[];
+
+    /*
+     *  YUV422 format, 1 plane (UYVY)
+     *
+     *  Effective bits per pixel : 16
+     *
+     *  Y sample at every pixel, U and V sampled at every second pixel horizontally on each line.
+     *  A macropixel contains 2 pixels in 1 uint32_t.
+     *
+     */
+    static const char PIXEL_FORMAT_YUV422I_UYVY[];
+    //
+    static const char PIXEL_FORMAT_YUV422I_VYUY[];
+    static const char PIXEL_FORMAT_YUV422I_YVYU[];
+    static const char PIXEL_FORMAT_BAYER8[];
+    static const char PIXEL_FORMAT_BAYER10[];
+    static const char PIXEL_FORMAT_BITSTREAM[];
+    static const char PIXEL_FORMAT_YUV420SP_NV12[];
+    /**
+     * @var KEY_BRIGHTNESS_VALUE
+     *
+     * This is a key string of brightness value, scaled by 10.
+     *
+     */
+    static const char KEY_BRIGHTNESS_VALUE[];
+
+    // ISP Operation mode for meta mode use
+    static const char KEY_ISP_MODE[];
+    // AF
+    static const char KEY_AF_X[];
+    static const char KEY_AF_Y[];
+    static const char KEY_FOCUS_ENG_MAX_STEP[];
+    static const char KEY_FOCUS_ENG_MIN_STEP[];
+    static const char KEY_FOCUS_ENG_BEST_STEP[];
+    static const char KEY_RAW_DUMP_FLAG[];
+    static const char KEY_PREVIEW_DUMP_RESOLUTION[];
+    static const int  PREVIEW_DUMP_RESOLUTION_NORMAL;
+    static const int  PREVIEW_DUMP_RESOLUTION_CROP;
+
+    // Values for effect
+    static const char EFFECT_SEPIA_BLUE[];
+    static const char EFFECT_SEPIA_GREEN[];
+    static const char  EFFECT_NASHVILLE[];
+    static const char  EFFECT_HEFE[];
+    static const char  EFFECT_VALENCIA[];
+    static const char  EFFECT_XPROII[];
+    static const char  EFFECT_LOFI[];
+    static const char  EFFECT_SIERRA[];
+    static const char  EFFECT_KELVIN[];
+    static const char  EFFECT_WALDEN[];;
+    static const char  EFFECT_F1977[];
+    // Values for AWB
+    static const char WHITE_BALANCE_TUNGSTEN[];
+    // Eng
+    static const char ISO_SPEED_ENG[];
+    static const char KEY_FOCUS_ENG_MODE[]; // 0,1,2,3 (0: normal)
+    static const char KEY_FOCUS_ENG_STEP[];
+    static const char KEY_RAW_SAVE_MODE[];  // on, off
+    static const char KEY_RAW_PATH[];
+
+    // KEY for Continuous shot speed
+    static const char KEY_FAST_CONTINUOUS_SHOT[];
+
+    // KEY for Video HDR
+    static const char KEY_VIDEO_HDR[];
+    static const char KEY_VIDEO_HDR_MODE[];
+    static const char VIDEO_HDR_MODE_IVHDR[];
+    static const char VIDEO_HDR_MODE_MVHDR[];
+    static const char VIDEO_HDR_MODE_ZVHDR[];
+    static const char VIDEO_HDR_SIZE_DEVISOR[];
+    // indicate that if single-frame capture HDR is supported
+    // Example value: "true" or "false". Read only.
+    static const char KEY_SINGLE_FRAME_CAPTURE_HDR_SUPPORTED[];
+
+    // MZAF from config table
+    static const char KEY_SUPPORT_MZAF_FEATURE[];
+
+    // indicate that if HDR detection is supported
+    // Example value: "true" or "false". Read only.
+    static const char KEY_HDR_DETECTION_SUPPORTED[];
+
+    // indicated by Camera APP that if HDR mode is auto or not
+    // Example value: "on" or "off". Read only.
+    static const char KEY_HDR_AUTO_MODE[];
+
+    // TODO: use this mode to replace KEY_HDR_AUTO_MODE and KEY_VIDEO_HDR
+    // KEY for HDR mode
+    static const char KEY_HDR_MODE[];
+
+    // Values for hdr mode settings.
+    //
+    // - disable high dynamic range imaging techniques
+    //
+    //   logically equivalent to
+    //   scene-mode ??SCENE_MODE_HDR
+    static const char HDR_MODE_OFF[];
+    // - capture a scene using high dynamic range imaging techniques
+    //
+    //   logically equivalent to
+    //   scene-mode = SCENE_MODE_HDR
+    static const char HDR_MODE_ON[];
+    // - capture a scene using high dynamic range imaging techniques
+    // - supports HDR scene detection
+    //
+    //   logically equivalent to
+    //   scene-mode = SCENE_MODE_HDR
+    //   hdr-auto-mode = on
+    static const char HDR_MODE_AUTO[];
+    // - capture/preview/record a scene using high dynamic range imaging techniques
+    //
+    //   logically equivalent to
+    //   scene-mode = SCENE_MODE_HDR
+    //   hdr-auto-mode = off
+    //   video-hdr = on
+    static const char HDR_MODE_VIDEO_ON[];
+    // - capture/preview/record a scene using high dynamic range imaging techniques
+    // - supports HDR scene detection
+    //
+    //   logically equivalent to
+    //   scene-mode = SCENE_MODE_HDR
+    //   hdr-auto-mode = on
+    //   video-hdr = on
+    static const char HDR_MODE_VIDEO_AUTO[];
+
+    static const char KEY_MAX_NUM_DETECTED_OBJECT[];
+
+    // HRD
+    static const char KEY_HEARTBEAT_MONITOR[];
+    static const char KEY_HEARTBEAT_MONITOR_SUPPORTED[];
+
+    // KEY for c_shot indicator
+    static const char KEY_CSHOT_INDICATOR[];
+    static const char KEY_SHUTTER_VALUE[];
+
+    // KEY for [Engineer Mode] Add new camera paramters for new requirements
+    static const char KEY_ENG_AE_ENABLE[];
+    static const char KEY_ENG_PREVIEW_SHUTTER_SPEED[];
+    static const char KEY_ENG_PREVIEW_SENSOR_GAIN[];
+    static const char KEY_ENG_PREVIEW_ISP_GAIN[];
+    static const char KEY_ENG_PREVIEW_AE_INDEX[];
+    static const char KEY_ENG_PREVIEW_ISO[];
+    static const char KEY_ENG_CAPTURE_SENSOR_GAIN[];
+    static const char KEY_ENG_CAPTURE_ISP_GAIN[];
+    static const char KEY_ENG_CAPTURE_SHUTTER_SPEED[];
+    static const char KEY_ENG_CAPTURE_ISO[];
+    static const char KEY_ENG_FLASH_DUTY_VALUE[];
+    static const char KEY_ENG_FLASH_DUTY_MIN[];
+    static const char KEY_ENG_FLASH_DUTY_MAX[];
+    static const char KEY_ENG_ZSD_ENABLE[];
+    static const char KEY_SENSOR_TYPE[];
+    static const char KEY_ENG_PREVIEW_FPS[];
+    static const char KEY_ENG_MSG[];
+    static const int  KEY_ENG_FLASH_DUTY_DEFAULT_VALUE;
+    static const int  KEY_ENG_FLASH_STEP_DEFAULT_VALUE;
+    static const char KEY_ENG_FLASH_STEP_MIN[];
+    static const char KEY_ENG_FLASH_STEP_MAX[];
+    static const char KEY_ENG_FOCUS_FULLSCAN_FRAME_INTERVAL[];
+    static const char KEY_ENG_FOCUS_FULLSCAN_FRAME_INTERVAL_MAX[];
+    static const char KEY_ENG_FOCUS_FULLSCAN_FRAME_INTERVAL_MIN[];
+    static const int  KEY_ENG_FOCUS_FULLSCAN_FRAME_INTERVAL_MAX_DEFAULT;
+    static const int  KEY_ENG_FOCUS_FULLSCAN_FRAME_INTERVAL_MIN_DEFAULT;
+    static const char KEY_ENG_FOCUS_FULLSCAN_DAC_STEP[];
+    static const char KEY_ENG_PREVIEW_FRAME_INTERVAL_IN_US[];
+    static const char KEY_ENG_PARAMETER1[];
+    static const char KEY_ENG_PARAMETER2[];
+    static const char KEY_ENG_PARAMETER3[];
+
+    //ENG KEY for RAW output port
+    static const char KEY_ENG_RAW_OUTPUT_PORT[];
+    static const int  KEY_ENG_RAW_IMGO;
+    static const int  KEY_ENG_RAW_RRZO;
+
+    //ENG KEY for ISP PROFILE
+    static const char KEY_ENG_ISP_PROFILE[];
+    static const int  KEY_ENG_ISP_PREVIEW;
+    static const int  KEY_ENG_ISP_CAPTURE;
+    static const int  KEY_ENG_ISP_VIDEO;
+
+    static const char KEY_ENG_EV_VALUE[];
+    static const char KEY_ENG_EVB_ENABLE[];
+
+    static const char KEY_ENG_3ADB_FLASH_ENABLE[];
+
+    static const char KEY_ENG_SAVE_SHADING_TABLE[];
+    static const char KEY_ENG_SHADING_TABLE[];
+    static const int KEY_ENG_SHADING_TABLE_AUTO;
+    static const int KEY_ENG_SHADING_TABLE_LOW;
+    static const int KEY_ENG_SHADING_TABLE_MIDDLE;
+    static const int KEY_ENG_SHADING_TABLE_HIGH;
+    static const int KEY_ENG_SHADING_TABLE_TSF;
+
+    static const char KEY_VR_BUFFER_COUNT[];
+
+    // KEY for [Engineer Mode] Add new camera paramters for ev calibration
+    static const char KEY_ENG_EV_CALBRATION_OFFSET_VALUE[];
+
+    // KEY for [Engineer Mode] MFLL: Multi-frame lowlight capture
+    static const char KEY_ENG_MFLL_SUPPORTED[];
+    static const char KEY_ENG_MFLL_ENABLE[];
+    static const char KEY_ENG_MFLL_PICTURE_COUNT[];
+
+    // KEY for [Engineer Mode] Two more sensor mode
+    static const char KEY_ENG_SENOSR_MODE_SLIM_VIDEO1_SUPPORTED[];
+    static const char KEY_ENG_SENOSR_MODE_SLIM_VIDEO2_SUPPORTED[];
+
+    // KEY for [Engineer Mode] Video raw dump
+    static const char KEY_ENG_VIDEO_RAW_DUMP_RESIZE_TO_2M_SUPPORTED[];
+    static const char KEY_ENG_VIDEO_RAW_DUMP_RESIZE_TO_4K2K_SUPPORTED[];
+    static const char KEY_ENG_VIDEO_RAW_DUMP_CROP_CENTER_2M_SUPPORTED[];
+    static const char KEY_ENG_VIDEO_RAW_DUMP_MANUAL_FRAME_RATE_SUPPORTED[];
+    static const char KEY_ENG_VIDEO_RAW_DUMP_MANUAL_FRAME_RATE_ENABLE[];
+    static const char KEY_ENG_VIDEO_RAW_DUMP_MANUAL_FRAME_RATE_MIN[];
+    static const char KEY_ENG_VIDEO_RAW_DUMP_MANUAL_FRAME_RATE_MAX[];
+    static const char KEY_ENG_VIDEO_RAW_DUMP_MANUAL_FRAME_RATE_RANGE_LOW[];
+    static const char KEY_ENG_VIDEO_RAW_DUMP_MANUAL_FRAME_RATE_RANGE_HIGH[];
+    static const char KEY_ENG_VIDEO_RAW_DUMP_RESIZE[];
+    static const char KEY_ENG_VIDEO_RAW_DUMP_SUPPORTED[];
+
+    static const char KEY_ENG_MTK_AWB_SUPPORTED[];
+    static const char KEY_ENG_SENSOR_AWB_SUPPORTED[];
+    static const char KEY_ENG_MTK_AWB_ENABLE[];
+    static const char KEY_ENG_SENSOR_AWB_ENABLE[];
+
+    static const char KEY_ENG_MTK_SHADING_SUPPORTED[];
+    static const char KEY_ENG_MTK_1to3_SHADING_SUPPORTED[];
+    static const char KEY_ENG_SENSOR_SHADNING_SUPPORTED[];
+    static const char KEY_ENG_MTK_SHADING_ENABLE[];
+    static const char KEY_ENG_MTK_1to3_SHADING_ENABLE[];
+    static const char KEY_ENG_SENSOR_SHADNING_ENABLE[];
+
+    static const char KEY_ENG_MANUAL_MULTI_NR_SUPPORTED[];
+    static const char KEY_ENG_MANUAL_MULTI_NR_ENABLE[];
+    static const char KEY_ENG_MANUAL_MULTI_NR_TYPE[];
+    static const char KEY_ENG_VIDEO_HDR_SUPPORTED[];
+    static const char KEY_ENG_VIDEO_HDR_MODE[];
+    static const char KEY_ENG_VIDEO_HDR_RATIO[];
+
+    // Slow Motion
+    static const char KEY_HSVR_PRV_SIZE[];
+    static const char KEY_SUPPORTED_HSVR_PRV_SIZE[];
+    static const char KEY_HSVR_PRV_FPS[];
+    static const char KEY_SUPPORTED_HSVR_PRV_FPS[];
+    static const char KEY_HSVR_SIZE_FPS[];
+    static const char KEY_SUPPORTED_HSVR_SIZE_FPS[];
+
+    // MFB
+    static const char KEY_MFB_MODE[];
+    static const char KEY_MFB_MODE_MFLL[];
+    static const char KEY_MFB_MODE_AIS[];
+
+    //PIP
+    static const char KEY_PIP_MAX_FRAME_RATE_ZSD_ON[];
+    static const char KEY_PIP_MAX_FRAME_RATE_ZSD_OFF[];
+
+    // Dynamic Frame Rate
+    static const char KEY_DYNAMIC_FRAME_RATE[];
+    static const char KEY_DYNAMIC_FRAME_RATE_SUPPORTED[];
+
+    // Stereo Feature
+    static const char KEY_STEREO_REFOCUS_MODE[];
+    static const char KEY_STEREO_CAPTURE_MODE[];
+    static const char KEY_STEREO_DEPTHAF_MODE[];
+    static const char KEY_STEREO_DISTANCE_MODE[];
+    static const char KEY_STEREO_PICTURE_SIZE[];
+    static const char KEY_SUPPORTED_STEREO_PICTURE_SIZE[];
+    static const char KEY_REFOCUS_PICTURE_SIZE[];
+    static const char KEY_SUPPORTED_REFOCUS_PICTURE_SIZE[];
+    static const char KEY_STEREO_PREVIEW_FRAME_RATE[];
+    static const char KEY_STEREO_CAPTURE_FRAME_RATE[];
+    static const char KEY_STEREO_SENSOR_INDEX_MAIN[];
+    static const char KEY_STEREO_SENSOR_INDEX_MAIN2[];
+    static const char KEY_STEREO_CAPTURE_SUPPORTED_MODULE[];
+    // Stereo Feature: VSDoF
+    static const char KEY_STEREO_VSDOF_MODE[];
+    static const char KEY_STEREO_DOF_LEVEL[];
+    static const char KEY_STEREO_SUPPORTED_DOF_LEVEL[];
+    static const char KEY_STEREO_RESULT_DOF_LEVEL[];
+    static const char KEY_STEREO_VSDOF_SUPPORTED_MODULE[];
+    static const char KEY_STEREO_TOUCH_POSITION[];
+    // Stereo Feature: De-noise
+    static const char KEY_STEREO_DENOISE_MODE[];
+    static const char KEY_STEREO_DENOISE_SUPPORTED_MODULE[];
+    // Stereo Feature: 3rd-Party
+    static const char KEY_STEREO_3RDPARTY_MODE[];
+    static const char KEY_STEREO_3RDPARTY_SUPPORTED_MODULE[];
+    // Stereo Feature: DualCam P2 control
+    static const char KEY_STEREO_PREVIEW_ENABLE[];
+
+    // Dual cam feature: capture
+    static const char KEY_DUALCAM_CAPTURE_MODE[];
+
+    // Image refocus
+    static const char KEY_REFOCUS_JPS_FILE_NAME[];
+
+    // 3DNR
+    static const char KEY_3DNR_MODE[];
+    static const char KEY_3DNR_QUALITY_SUPPORTED[];
+
+    static const char KEY_EIS_SUPPORTED_FRAMES[];
+    static const char KEY_EIS25_MODE[];
+
+    // for manual exposure time / sensor gain
+    static const char KEY_ENG_MANUAL_SHUTTER_SPEED [];
+    static const char KEY_ENG_MANUAL_SENSOR_GAIN[];
+
+    // Flash Calibration
+    static const char KEY_ENG_FLASH_CALIBRATION[];
+
+    // for sensor mode
+    static const char KEY_ENG_SENOSR_MODE_SUPPORTED[];
+
+    // Gesture Shot
+    static const char KEY_GESTURE_SHOT[];
+    static const char KEY_GESTURE_SHOT_SUPPORTED[];
+
+    // Native PIP
+    static const char KEY_NATIVE_PIP[];
+    static const char KEY_NATIVE_PIP_SUPPORTED[];
+
+    // PDAF
+    static const char KEY_PDAF[];
+    static const char KEY_PDAF_SUPPORTED[];
+
+    // first display frame black
+    static const char KEY_FIRST_PREVIEW_FRAME_BLACK[];
+
+    //DNG
+    static const char KEY_DNG_SUPPORTED[];
+
+    // Display Rotation
+    static const char KEY_DISPLAY_ROTATION_SUPPORTED[];
+    static const char KEY_PANEL_SIZE[];
+
+    //multi-zone AF window
+    static const char KEY_IS_SUPPORT_MZAF[];
+    static const char KEY_MZAF_ENABLE[];
+
+    // post-view
+    static const char KEY_POST_VIEW_FMT[];
+
+public:     ////    on/off => FIXME: should be replaced with TRUE[]
+    static const char ON[];
+    static const char OFF[];
+
+    static const char REAR[];
+    static const char FRONT[];
+};
+
+}; // namespace android
+
+#endif
diff --git a/media/libaudiohal/Android.mk b/media/libaudiohal/Android.mk
index 827908ec88..38ddb7b4b7 100644
--- a/media/libaudiohal/Android.mk
+++ b/media/libaudiohal/Android.mk
@@ -17,6 +17,10 @@ LOCAL_SRC_FILES := \
 
 LOCAL_CFLAGS := -Wall -Werror
 
+ifeq ($(BOARD_USES_LEGACY_MTK_AV_BLOB), true)
+    LOCAL_CFLAGS += -DLEGACY_MTK_AV_BLOB
+endif
+
 ifeq ($(USE_LEGACY_LOCAL_AUDIO_HAL), true)
 
 # Use audiohal directly w/o hwbinder middleware.
diff --git a/media/libaudiohal/DeviceHalLocal.cpp b/media/libaudiohal/DeviceHalLocal.cpp
index fc098f5136..acbfc8b2d2 100644
--- a/media/libaudiohal/DeviceHalLocal.cpp
+++ b/media/libaudiohal/DeviceHalLocal.cpp
@@ -137,8 +137,20 @@ status_t DeviceHalLocal::openInputStream(
             handle, devices, flags,
             config->sample_rate, config->format, config->channel_mask,
             address, source);
+#ifdef LEGACY_MTK_AV_BLOB
+    halStream = (audio_stream_in_t *)calloc(1, sizeof(audio_stream_in_t));
+    int openResult = mDev->open_input_stream(
+            mDev, handle, devices, config, &mIn, flags, address, source);
+    memcpy(halStream, mIn, sizeof(legacy_audio_stream_in_t));
+    halStream->get_capture_position = NULL;
+    halStream->start = NULL;
+    halStream->stop = NULL;
+    halStream->create_mmap_buffer = NULL;
+    halStream->get_mmap_position = NULL;
+#else
     int openResult = mDev->open_input_stream(
             mDev, handle, devices, config, &halStream, flags, address, source);
+#endif
     if (openResult == OK) {
         *inStream = new StreamInHalLocal(halStream, this);
     }
@@ -193,7 +205,12 @@ void DeviceHalLocal::closeOutputStream(struct audio_stream_out *stream_out) {
 }
 
 void DeviceHalLocal::closeInputStream(struct audio_stream_in *stream_in) {
+#ifdef LEGACY_MTK_AV_BLOB
+    mDev->close_input_stream(mDev, mIn);
+    free(stream_in);
+#else
     mDev->close_input_stream(mDev, stream_in);
+#endif
 }
 
 } // namespace android
diff --git a/media/libaudiohal/DeviceHalLocal.h b/media/libaudiohal/DeviceHalLocal.h
index 865f2968e1..6cc560130b 100644
--- a/media/libaudiohal/DeviceHalLocal.h
+++ b/media/libaudiohal/DeviceHalLocal.h
@@ -107,7 +107,9 @@ class DeviceHalLocal : public DeviceHalInterface
 
   private:
     audio_hw_device_t *mDev;
-
+#ifdef LEGACY_MTK_AV_BLOB
+    audio_stream_in_t *mIn;
+#endif
     friend class DevicesFactoryHalLocal;
 
     // Can not be constructed directly by clients.
diff --git a/media/libmedia/MediaProfiles.cpp b/media/libmedia/MediaProfiles.cpp
index 4de43c57a5..9df5930447 100644
--- a/media/libmedia/MediaProfiles.cpp
+++ b/media/libmedia/MediaProfiles.cpp
@@ -40,6 +40,7 @@ const MediaProfiles::NameToTagMap MediaProfiles::sVideoEncoderNameMap[] = {
     {"h263", VIDEO_ENCODER_H263},
     {"h264", VIDEO_ENCODER_H264},
     {"m4v",  VIDEO_ENCODER_MPEG_4_SP},
+    {"h265", VIDEO_ENCODER_H265},
     {"hevc", VIDEO_ENCODER_HEVC}
 };
 
@@ -48,7 +49,11 @@ const MediaProfiles::NameToTagMap MediaProfiles::sAudioEncoderNameMap[] = {
     {"amrwb",  AUDIO_ENCODER_AMR_WB},
     {"aac",    AUDIO_ENCODER_AAC},
     {"heaac",  AUDIO_ENCODER_HE_AAC},
-    {"aaceld", AUDIO_ENCODER_AAC_ELD}
+#ifdef MTK_HARDWARE
+    {"vorbis", AUDIO_ENCODER_VORBIS},
+#endif
+    {"aaceld", AUDIO_ENCODER_AAC_ELD},
+    {"lpcm",  AUDIO_ENCODER_LPCM}
 };
 
 const MediaProfiles::NameToTagMap MediaProfiles::sFileFormatMap[] = {
@@ -104,6 +109,50 @@ const MediaProfiles::NameToTagMap MediaProfiles::sCamcorderQualityNameMap[] = {
     {"2k", CAMCORDER_QUALITY_2k},
     {"timelapseqhd", CAMCORDER_QUALITY_TIME_LAPSE_QHD},
     {"timelapse2k", CAMCORDER_QUALITY_TIME_LAPSE_2k},
+
+#ifdef MTK_HARDWARE
+    {"mtklow", CAMCORDER_QUALITY_MTK_LOW},
+    {"mtkmedium", CAMCORDER_QUALITY_MTK_MEDIUM},
+    {"mtkhigh", CAMCORDER_QUALITY_MTK_HIGH},
+    {"mtkfine", CAMCORDER_QUALITY_MTK_FINE},
+
+    {"mtknightlow", CAMCORDER_QUALITY_MTK_NIGHT_LOW},
+    {"mtknightmedium", CAMCORDER_QUALITY_MTK_NIGHT_MEDIUM},
+    {"mtknighthigh", CAMCORDER_QUALITY_MTK_NIGHT_HIGH},
+    {"mtknightfine", CAMCORDER_QUALITY_MTK_NIGHT_FINE},
+
+    {"mtkliveeffect", CAMCORDER_QUALITY_MTK_LIVE_EFFECT},
+    {"mtkh264high", CAMCORDER_QUALITY_MTK_H264_HIGH},
+    {"mtkmpeg41080p", CAMCORDER_QUALITY_MTK_MPEG4_1080P},
+    {"mtkfine4k2k", CAMCORDER_QUALITY_MTK_FINE_4K2K},
+
+    {"mtktimelapselow", CAMCORDER_QUALITY_MTK_TIME_LAPSE_LOW},
+    {"mtktimelapsemedium", CAMCORDER_QUALITY_MTK_TIME_LAPSE_MEDIUM},
+    {"mtktimelapsehigh", CAMCORDER_QUALITY_MTK_TIME_LAPSE_HIGH},
+    {"mtktimelapsefine", CAMCORDER_QUALITY_MTK_TIME_LAPSE_FINE},
+
+    {"mtktimelapsenightlow", CAMCORDER_QUALITY_MTK_TIME_LAPSE_NIGHT_LOW},
+    {"mtktimelapsenightmedium", CAMCORDER_QUALITY_MTK_TIME_LAPSE_NIGHT_MEDIUM},
+    {"mtktimelapsenighthigh", CAMCORDER_QUALITY_MTK_TIME_LAPSE_NIGHT_HIGH},
+    {"mtktimelapsenightfine", CAMCORDER_QUALITY_MTK_TIME_LAPSE_NIGHT_FINE},
+
+    {"mtktimelapseliveeffect", CAMCORDER_QUALITY_MTK_TIME_LAPSE_LIVE_EFFECT},
+    {"mtktimelapseh264high", CAMCORDER_QUALITY_MTK_TIME_LAPSE_H264_HIGH},
+    {"mtktimelapsempeg41080p", CAMCORDER_QUALITY_MTK_TIME_LAPSE_MPEG4_1080P},
+    {"mtktimelapsefine4k2k", CAMCORDER_QUALITY_MTK_TIME_LAPSE_FINE_4K2K},
+
+    {"mtkslowmotionlow", CAMCORDER_QUALITY_MTK_SLOW_MOTION_LOW},
+    {"mtkslowmotionmedium", CAMCORDER_QUALITY_MTK_SLOW_MOTION_MEDIUM},
+    {"mtkslowmotionhigh", CAMCORDER_QUALITY_MTK_SLOW_MOTION_HIGH},
+    {"mtkslowmotionfine", CAMCORDER_QUALITY_MTK_SLOW_MOTION_FINE},
+
+    {"mtkvga120", CAMCORDER_QUALITY_MTK_VGA_120},
+    {"mtk720p60", CAMCORDER_QUALITY_MTK_720P_60},
+    {"mtk720p120", CAMCORDER_QUALITY_MTK_720P_120},
+    {"mtk720p180", CAMCORDER_QUALITY_MTK_720P_180},
+    {"mtk1080p60", CAMCORDER_QUALITY_MTK_1080P_60},
+    {"mtk1080p120", CAMCORDER_QUALITY_MTK_1080P_120},
+#endif // (MTK_HARDWARE)
 };
 
 #if LOG_NDEBUG
@@ -193,6 +242,7 @@ MediaProfiles::createVideoCodec(const char **atts, MediaProfiles *profiles)
 
     const size_t nMappings = sizeof(sVideoEncoderNameMap)/sizeof(sVideoEncoderNameMap[0]);
     const int codec = findTagForName(sVideoEncoderNameMap, nMappings, atts[1]);
+    ALOGD("createVideoEncoderCap: checking Video Codec name: %s",atts[1]);
     CHECK(codec != -1);
 
     MediaProfiles::VideoCodec *videoCodec =
@@ -215,6 +265,7 @@ MediaProfiles::createAudioCodec(const char **atts, MediaProfiles *profiles)
           !strcmp("channels",   atts[6]));
     const size_t nMappings = sizeof(sAudioEncoderNameMap)/sizeof(sAudioEncoderNameMap[0]);
     const int codec = findTagForName(sAudioEncoderNameMap, nMappings, atts[1]);
+    ALOGD("createAudioEncoderCap: checking Audio Codec name: %s",atts[1]);
     CHECK(codec != -1);
 
     MediaProfiles::AudioCodec *audioCodec =
diff --git a/media/libmedia/include/media/MediaProfiles.h b/media/libmedia/include/media/MediaProfiles.h
index b3ab08dd8d..caceb64df4 100644
--- a/media/libmedia/include/media/MediaProfiles.h
+++ b/media/libmedia/include/media/MediaProfiles.h
@@ -34,7 +34,23 @@ enum camcorder_quality {
     CAMCORDER_QUALITY_1080P = 6,
     CAMCORDER_QUALITY_QVGA = 7,
     CAMCORDER_QUALITY_2160P = 8,
+#ifdef MTK_HARDWARE
+    CAMCORDER_QUALITY_MTK_LOW              = 108,
+    CAMCORDER_QUALITY_MTK_MEDIUM           = 109,
+    CAMCORDER_QUALITY_MTK_HIGH             = 110,
+    CAMCORDER_QUALITY_MTK_FINE             = 111,
+    CAMCORDER_QUALITY_MTK_NIGHT_LOW        = 112,
+    CAMCORDER_QUALITY_MTK_NIGHT_MEDIUM     = 113,
+    CAMCORDER_QUALITY_MTK_NIGHT_HIGH       = 114,
+    CAMCORDER_QUALITY_MTK_NIGHT_FINE       = 115,
+    CAMCORDER_QUALITY_MTK_LIVE_EFFECT      = 116,
+    CAMCORDER_QUALITY_MTK_H264_HIGH        = 117,
+    CAMCORDER_QUALITY_MTK_MPEG4_1080P      = 118,
+    CAMCORDER_QUALITY_MTK_FINE_4K2K        = 123,
+    CAMCORDER_QUALITY_LIST_END             = 123,
+#else
     CAMCORDER_QUALITY_LIST_END = 8,
+#endif// MTK_HARDWARE
 
     CAMCORDER_QUALITY_TIME_LAPSE_LIST_START = 1000,
     CAMCORDER_QUALITY_TIME_LAPSE_LOW  = 1000,
@@ -46,7 +62,23 @@ enum camcorder_quality {
     CAMCORDER_QUALITY_TIME_LAPSE_1080P = 1006,
     CAMCORDER_QUALITY_TIME_LAPSE_QVGA = 1007,
     CAMCORDER_QUALITY_TIME_LAPSE_2160P = 1008,
+#ifdef MTK_HARDWARE
+    CAMCORDER_QUALITY_MTK_TIME_LAPSE_LOW              = 1108,
+    CAMCORDER_QUALITY_MTK_TIME_LAPSE_MEDIUM           = 1109,
+    CAMCORDER_QUALITY_MTK_TIME_LAPSE_HIGH             = 1110,
+    CAMCORDER_QUALITY_MTK_TIME_LAPSE_FINE             = 1111,
+    CAMCORDER_QUALITY_MTK_TIME_LAPSE_NIGHT_LOW        = 1112,
+    CAMCORDER_QUALITY_MTK_TIME_LAPSE_NIGHT_MEDIUM     = 1113,
+    CAMCORDER_QUALITY_MTK_TIME_LAPSE_NIGHT_HIGH       = 1114,
+    CAMCORDER_QUALITY_MTK_TIME_LAPSE_NIGHT_FINE       = 1115,
+    CAMCORDER_QUALITY_MTK_TIME_LAPSE_LIVE_EFFECT      = 1116,
+    CAMCORDER_QUALITY_MTK_TIME_LAPSE_H264_HIGH        = 1117,
+    CAMCORDER_QUALITY_MTK_TIME_LAPSE_MPEG4_1080P      = 1118,
+    CAMCORDER_QUALITY_MTK_TIME_LAPSE_FINE_4K2K        = 1123,
+    CAMCORDER_QUALITY_TIME_LAPSE_LIST_END             = 1123,
+#else
     CAMCORDER_QUALITY_TIME_LAPSE_LIST_END = 1008,
+#endif// MTK_HARDWARE
 
     CAMCORDER_QUALITY_HIGH_SPEED_LIST_START = 2000,
     CAMCORDER_QUALITY_HIGH_SPEED_LOW  = 2000,
@@ -55,8 +87,24 @@ enum camcorder_quality {
     CAMCORDER_QUALITY_HIGH_SPEED_720P = 2003,
     CAMCORDER_QUALITY_HIGH_SPEED_1080P = 2004,
     CAMCORDER_QUALITY_HIGH_SPEED_2160P = 2005,
+#ifdef MTK_HARDWARE
+    CAMCORDER_QUALITY_MTK_SLOW_MOTION_LIST_START    = 2219,
+    CAMCORDER_QUALITY_MTK_SLOW_MOTION_LOW           = 2219,
+    CAMCORDER_QUALITY_MTK_SLOW_MOTION_MEDIUM        = 2220,
+    CAMCORDER_QUALITY_MTK_SLOW_MOTION_HIGH          = 2221,
+    CAMCORDER_QUALITY_MTK_SLOW_MOTION_FINE          = 2222,
+
+    CAMCORDER_QUALITY_MTK_VGA_120                   = 2231,
+    CAMCORDER_QUALITY_MTK_720P_60                   = 2240,
+    CAMCORDER_QUALITY_MTK_720P_120                  = 2241,
+    CAMCORDER_QUALITY_MTK_720P_180                  = 2242,
+    CAMCORDER_QUALITY_MTK_1080P_60                  = 2250,
+    CAMCORDER_QUALITY_MTK_1080P_120                 = 2251,
+    CAMCORDER_QUALITY_MTK_SLOW_MOTION_LIST_END      = 2251,
+    CAMCORDER_QUALITY_HIGH_SPEED_LIST_END           = 2251,
+#else
     CAMCORDER_QUALITY_HIGH_SPEED_LIST_END = 2005,
-
+#endif// MTK_HARDWARE
     CAMCORDER_QUALITY_VENDOR_START = 10000,
     CAMCORDER_QUALITY_VGA = 10000,
     CAMCORDER_QUALITY_4KDCI = 10001,
diff --git a/media/libmedia/include/media/mediarecorder.h b/media/libmedia/include/media/mediarecorder.h
index 071e7a1a1b..3e8d6b729f 100644
--- a/media/libmedia/include/media/mediarecorder.h
+++ b/media/libmedia/include/media/mediarecorder.h
@@ -77,6 +77,9 @@ enum output_format {
     /* VP8/VORBIS data in a WEBM container */
     OUTPUT_FORMAT_WEBM = 9,
 
+    OUTPUT_FORMAT_QCP = 20,
+    OUTPUT_FORMAT_WAVE = 21,
+
     OUTPUT_FORMAT_LIST_END // must be last - used to validate format type
 };
 
@@ -89,6 +92,10 @@ enum audio_encoder {
     AUDIO_ENCODER_AAC_ELD = 5,
     AUDIO_ENCODER_VORBIS = 6,
 
+    AUDIO_ENCODER_EVRC = 10,
+    AUDIO_ENCODER_QCELP = 11,
+    AUDIO_ENCODER_LPCM = 12,
+
     AUDIO_ENCODER_LIST_END // must be the last - used to validate the audio encoder type
 };
 
@@ -100,7 +107,11 @@ enum video_encoder {
     VIDEO_ENCODER_VP8 = 4,
     VIDEO_ENCODER_HEVC = 5,
 
-    VIDEO_ENCODER_LIST_END // must be the last - used to validate the video encoder type
+    VIDEO_ENCODER_LIST_END, // must be the last - used to validate the video encoder type
+
+    VIDEO_ENCODER_LIST_VENDOR_START = 1000,
+    VIDEO_ENCODER_H265 = 1001,
+    VIDEO_ENCODER_LIST_VENDOR_END
 };
 
 /*
diff --git a/media/libmediaplayerservice/StagefrightRecorder.cpp b/media/libmediaplayerservice/StagefrightRecorder.cpp
index c58dcb9b08..c0eeb9856e 100644
--- a/media/libmediaplayerservice/StagefrightRecorder.cpp
+++ b/media/libmediaplayerservice/StagefrightRecorder.cpp
@@ -1581,7 +1581,7 @@ status_t StagefrightRecorder::setupCameraSource(
         *cameraSource = CameraSource::CreateFromCamera(
                 mCamera, mCameraProxy, mCameraId, mClientName, mClientUid, mClientPid,
                 videoSize, mFrameRate,
-                mPreviewSurface);
+                mPreviewSurface, false); // [*] Decker
     }
     mCamera.clear();
     mCameraProxy.clear();
diff --git a/media/libstagefright/ACodec.cpp b/media/libstagefright/ACodec.cpp
index def8ada3c3..b22891eebc 100644
--- a/media/libstagefright/ACodec.cpp
+++ b/media/libstagefright/ACodec.cpp
@@ -62,6 +62,12 @@
 #include "include/SharedMemoryBuffer.h"
 #include <media/stagefright/omx/OMXUtils.h>
 
+#ifndef MTK_HARDWARE
+#define MTK_HARDWARE
+#endif
+
+#define USE_LEGACY_RESCALING 1
+
 namespace android {
 
 using binder::Status;
@@ -1106,6 +1112,10 @@ status_t ACodec::setupNativeWindowSizeFormatAndUsage(
         usage |= GRALLOC_USAGE_PROTECTED;
     }
 
+#ifdef MTK_HARDWARE
+    usage |= (GRALLOC_USAGE_SW_WRITE_OFTEN | GRALLOC_USAGE_SW_READ_OFTEN);
+#endif
+
     usage |= kVideoGrallocUsage;
     *finalUsage = usage;
 
@@ -3190,7 +3200,12 @@ status_t ACodec::setSupportedOutputFormat(bool getLegacyFlexibleFormat) {
                 || format.eColorFormat == OMX_COLOR_FormatYUV420PackedPlanar
                 || format.eColorFormat == OMX_COLOR_FormatYUV420SemiPlanar
                 || format.eColorFormat == OMX_COLOR_FormatYUV420PackedSemiPlanar
-                || format.eColorFormat == OMX_TI_COLOR_FormatYUV420PackedSemiPlanar) {
+                || format.eColorFormat == OMX_TI_COLOR_FormatYUV420PackedSemiPlanar
+#ifdef MTK_HARDWARE
+                || format.eColorFormat == HAL_PIXEL_FORMAT_YV12
+                || format.eColorFormat == OMX_MTK_COLOR_FormatYV12
+#endif
+                ) {
             break;
         }
         // find best legacy non-standard format
@@ -4841,6 +4856,17 @@ status_t ACodec::getPortFormat(OMX_U32 portIndex, sp<AMessage> &notify) {
                             rect.nHeight = videoDef->nFrameHeight;
                         }
 
+#ifdef MTK_HARDWARE
+						if (!strncmp(mComponentName.c_str(), "OMX.MTK.", 8) && mOMXNode->getConfig(
+								(OMX_INDEXTYPE) 0x7f00001c /* OMX_IndexVendorMtkOmxVdecGetCropInfo */,
+								&rect, sizeof(rect)) != OK) {
+							rect.nLeft = 0;
+							rect.nTop = 0;
+							rect.nWidth = videoDef->nFrameWidth;
+							rect.nHeight = videoDef->nFrameHeight;
+						}
+#endif
+
                         if (rect.nLeft < 0 ||
                             rect.nTop < 0 ||
                             rect.nLeft + rect.nWidth > videoDef->nFrameWidth ||
@@ -7888,6 +7914,15 @@ bool ACodec::OutputPortSettingsChangedState::onOMXEvent(
                     return false;
                 }
 
+#ifdef USE_LEGACY_RESCALING
+                // Resolution is about to change
+                // Make sure the decoder knows
+                sp<AMessage> reply = new AMessage(kWhatOutputBufferDrained, mCodec);
+                mCodec->onOutputFormatChanged();
+                mCodec->addKeyFormatChangesToRenderBufferNotification(reply);
+                mCodec->sendFormatChange();
+#endif
+
                 ALOGV("[%s] Output port now reenabled.", mCodec->mComponentName.c_str());
 
                 if (mCodec->mExecutingState->active()) {
@@ -7902,6 +7937,14 @@ bool ACodec::OutputPortSettingsChangedState::onOMXEvent(
             return false;
         }
 
+#ifdef USE_LEGACY_RESCALING
+        case OMX_EventPortSettingsChanged:
+            // Exynos OMX wants to share its' output crop
+            // For some reason trying to handle this here doesn't do anything
+            // We'll do it right before transitioning to ExecutingState
+            return true;
+        break;
+#endif
         default:
             return BaseState::onOMXEvent(event, data1, data2);
     }
@@ -8463,6 +8506,25 @@ status_t ACodec::getOMXChannelMapping(size_t numChannels, OMX_AUDIO_CHANNELTYPE
     return OK;
 }
 
+#ifdef USE_LEGACY_RESCALING
+void ACodec::addKeyFormatChangesToRenderBufferNotification(sp<AMessage> &notify) {
+    AString mime;
+    CHECK(mOutputFormat->findString("mime", &mime));
+    if (mime == MEDIA_MIMETYPE_VIDEO_RAW && mNativeWindow != NULL) {
+        // notify renderer of the crop change and dataspace change
+        // NOTE: native window uses extended right-bottom coordinate
+        int32_t left, top, right, bottom;
+        if (mOutputFormat->findRect("crop", &left, &top, &right, &bottom)) {
+            notify->setRect("crop", left, top, right + 1, bottom + 1);
+        }
+        int32_t dataSpace;
+        if (mOutputFormat->findInt32("android._dataspace", &dataSpace)) {
+            notify->setInt32("dataspace", dataSpace);
+        }
+    }
+}
+#endif
+
 void ACodec::setTrebleFlag(bool trebleFlag) {
     mTrebleFlag = trebleFlag;
 }
diff --git a/media/libstagefright/Android.bp b/media/libstagefright/Android.bp
index c8d4e4aaa6..66c9e382fc 100644
--- a/media/libstagefright/Android.bp
+++ b/media/libstagefright/Android.bp
@@ -108,6 +108,7 @@ cc_library_shared {
         "android.hardware.cas@1.0",
         "android.hardware.cas.native@1.0",
         "android.hardware.media.omx@1.0",
+        "libdpframework"
     ],
 
     static_libs: [
@@ -132,6 +133,7 @@ cc_library_shared {
 
     export_include_dirs: [
         "include",
+        "colorconversion/inc",
     ],
 
     cflags: [
@@ -139,12 +141,17 @@ cc_library_shared {
         "-Werror",
         "-Wno-error=deprecated-declarations",
         "-Wall",
+        "-DMTK_HARDWARE",
     ],
 
     product_variables: {
         debuggable: {
             // enable experiments only in userdebug and eng builds
-            cflags: ["-DENABLE_STAGEFRIGHT_EXPERIMENTS"],
+            cflags: [
+                "-DENABLE_STAGEFRIGHT_EXPERIMENTS",
+                "-DMTK_HARDWARE",
+                "-DUSE_LEGACY_MTK_AV_BLOB",
+            ],
         },
     },
 
diff --git a/media/libstagefright/CameraSource.cpp b/media/libstagefright/CameraSource.cpp
index 399199e381..ca9a449138 100644
--- a/media/libstagefright/CameraSource.cpp
+++ b/media/libstagefright/CameraSource.cpp
@@ -134,14 +134,34 @@ static int32_t getColorFormat(const char* colorFormat) {
         return -1;
     }
 
+#ifdef MTK_HARDWARE
+    ALOGD("getColorFormat(%s)", colorFormat);
+
+    if (!strcmp(colorFormat, CameraParameters::PIXEL_FORMAT_YUV420P)) {
+        // YV12
+        return OMX_MTK_COLOR_FormatYV12;
+    }
+
+    if (!strcmp(colorFormat, "yuv420i-yyuvyy-3plane" /*MtkCameraParameters::PIXEL_FORMAT_YUV420I)*/)) {
+        // i420
+        return OMX_COLOR_FormatYUV420Planar;
+    }
+#else
     if (!strcmp(colorFormat, CameraParameters::PIXEL_FORMAT_YUV420P)) {
        return OMX_COLOR_FormatYUV420Planar;
     }
+#endif
 
     if (!strcmp(colorFormat, CameraParameters::PIXEL_FORMAT_YUV422SP)) {
        return OMX_COLOR_FormatYUV422SemiPlanar;
     }
 
+#ifdef MTK_HARDWARE
+    if (!strcmp(colorFormat, "bitstream")) {
+       return OMX_COLOR_FormatYUV420Planar;
+    }
+#endif
+
     if (!strcmp(colorFormat, CameraParameters::PIXEL_FORMAT_YUV420SP)) {
         return OMX_COLOR_FormatYUV420SemiPlanar;
     }
diff --git a/media/libstagefright/MPEG4Writer.cpp b/media/libstagefright/MPEG4Writer.cpp
index 7786c4de0c..a90675eb91 100644
--- a/media/libstagefright/MPEG4Writer.cpp
+++ b/media/libstagefright/MPEG4Writer.cpp
@@ -1248,6 +1248,12 @@ static void StripStartcode(MediaBuffer *buffer) {
         buffer->set_range(
                 buffer->range_offset() + 4, buffer->range_length() - 4);
     }
+#ifdef MTK_HARDWARE //&& defined(MTK_VIDEO_HEVC_SUPPORT)
+	else if (!memcmp(ptr, "\x00\x00\x01", 3)) {
+		ALOGV("StripStartcode 00 00 01 for HEVC directlink");
+		buffer->set_range(buffer->range_offset() + 3, buffer->range_length() - 3);
+	}
+#endif
 }
 
 off64_t MPEG4Writer::addMultipleLengthPrefixedSamples_l(MediaBuffer *buffer) {
diff --git a/media/libstagefright/colorconversion/Android.bp b/media/libstagefright/colorconversion/Android.bp
index 16e9ded0ea..f8666f4f6c 100644
--- a/media/libstagefright/colorconversion/Android.bp
+++ b/media/libstagefright/colorconversion/Android.bp
@@ -8,16 +8,21 @@ cc_library_static {
 
     include_dirs: [
         "frameworks/native/include/media/openmax",
+        "frameworks/av/media/libstagefright/colorconversion/inc",
     ],
 
     shared_libs: [
         "libui",
         "libnativewindow",
+        "libdpframework",
     ],
 
     static_libs: ["libyuv_static"],
 
-    cflags: ["-Werror"],
+    cflags: [
+        "-Werror",
+        "-DMTK_HARDWARE",
+    ],
 
     sanitize: {
         misc_undefined: [
diff --git a/media/libstagefright/colorconversion/ColorConverter.cpp b/media/libstagefright/colorconversion/ColorConverter.cpp
index 0982006af1..fe18955403 100644
--- a/media/libstagefright/colorconversion/ColorConverter.cpp
+++ b/media/libstagefright/colorconversion/ColorConverter.cpp
@@ -25,6 +25,17 @@
 #include "libyuv/convert_from.h"
 #include "libyuv/video_common.h"
 
+#ifdef MTK_HARDWARE
+#include <OMX_IVCommon.h>
+#include <cutils/properties.h>
+#include <DpBlitStream.h>
+#include <stdio.h>
+#include <utils/Timers.h>
+#include <inttypes.h>
+
+//static const int OMX_MTK_COLOR_FormatYV12 = 0x7F000200;
+#endif
+
 #define USE_LIBYUV
 
 namespace android {
@@ -42,6 +53,16 @@ ColorConverter::~ColorConverter() {
 }
 
 bool ColorConverter::isValid() const {
+#ifdef MTK_HARDWARE
+ALOGD("***isValid() mSrcFormat=0x%x,mDstFormat=0x%x",mSrcFormat,mDstFormat);
+    if ((mDstFormat != OMX_COLOR_Format16bitRGB565) &&
+        (mDstFormat != OMX_COLOR_Format32bitARGB8888)) {
+        return ERROR_UNSUPPORTED;
+    }
+    if ((mSrcFormat == OMX_COLOR_Format32bitARGB8888) ||
+        (mSrcFormat == OMX_MTK_COLOR_FormatYV12))
+        return true;
+#endif
     switch (mSrcFormat) {
         case OMX_COLOR_FormatYUV420Planar:
             return mDstFormat == OMX_COLOR_Format16bitRGB565
@@ -53,6 +74,13 @@ bool ColorConverter::isValid() const {
         case OMX_COLOR_FormatYUV420SemiPlanar:
         case OMX_TI_COLOR_FormatYUV420PackedSemiPlanar:
             return mDstFormat == OMX_COLOR_Format16bitRGB565;
+#ifdef MTK_HARDWARE
+        case OMX_COLOR_Format32bitARGB8888:
+        case OMX_MTK_COLOR_FormatYV12:
+        case OMX_COLOR_FormatVendorMTKYUV:
+        case OMX_COLOR_FormatVendorMTKYUV_FCM:
+            return true;
+#endif
 
         default:
             return false;
@@ -649,4 +677,153 @@ uint8_t *ColorConverter::initClip() {
     return &mClip[-kClipMin];
 }
 
+#ifdef MTK_HARDWARE
+status_t ColorConverter::convertYUVToRGBHW(const BitmapParams &src, const BitmapParams &dst)
+{
+    ALOGD("srcWidth(%zu), srcHeight(%zu), srcCropLeft(%zu), srcCropTop(%zu), srcCropRight(%zu), srcCropBottom(%zu)",
+       src.mWidth, src.mHeight, src.mCropLeft, src.mCropTop, src.mCropRight, src.mCropBottom);
+    ALOGD("dstWidth(%zu), dstHeight(%zu), dstCropLeft(%zu), dstCropTop(%zu), dstCropRight(%zu), dstCropBottom(%zu)",
+       dst.mWidth, dst.mHeight, dst.mCropLeft, dst.mCropTop, dst.mCropRight, dst.mCropBottom);
+    DpBlitStream *blitStream = new DpBlitStream();
+    //int srcWidth = src.cropWidth();
+    //int srcHeight = src.cropHeight();
+    unsigned int srcWStride = src.mWidth;
+    unsigned int srcHStride = src.mHeight;
+
+    DpRect srcRoi;
+    srcRoi.x = 0;
+    srcRoi.y = 0;
+    srcRoi.w = dst.mWidth;
+    srcRoi.h = dst.mHeight;
+
+    ALOGD("src stride aligned, w(%d), h(%d)", srcWStride, srcHStride);
+
+    unsigned int dstWStride = dst.mWidth ;
+    unsigned int dstHStride = dst.mHeight ;
+    char name_yuv[100];
+    char retriever_yuv_propty[100];
+    char name_rgb[100];
+    char retriever_propty_rgb[100];
+
+    if (mSrcFormat == OMX_COLOR_FormatYUV420Planar) {
+    char* planar[3];
+    unsigned int length[3];
+    planar[0] = (char*)src.mBits;
+    length[0] = srcWStride*srcHStride;
+    planar[1] = planar[0] + length[0];
+    length[1] = srcWStride*srcHStride/4;
+    planar[2] = planar[1] + length[1];
+    length[2] = length[1];
+    ALOGD("Yaddr(%p), Uaddr(%p), Vaddr(%p) YUV420P", planar[0], planar[1], planar[2]);
+    ALOGD("Ylen(%d), Ulen(%d), Vlen(%d)", length[0], length[1], length[2]);
+
+    blitStream->setSrcBuffer((void**)planar, (unsigned int*)length, 3);
+    blitStream->setSrcConfig(srcWStride, srcHStride, eYUV_420_3P, eInterlace_None, &srcRoi);
+    }
+    else if (mSrcFormat == OMX_MTK_COLOR_FormatYV12) {
+        char* planar[3];
+        unsigned int length[3];
+        planar[0] = (char*)src.mBits;
+        length[0] = srcWStride*srcHStride;
+        planar[1] = planar[0] + length[0];
+        length[1] = (((srcWStride>>1)+0xf) & (~0xf))*srcHStride/2;
+        planar[2] = planar[1] + length[1];
+        length[2] = length[1];
+        ALOGD("Yaddr(%p), Uaddr(%p), Vaddr(%p) YV12", planar[0], planar[1], planar[2]);
+        ALOGD("Ylen(%d), Ulen(%d), Vlen(%d)", length[0], length[1], length[2]);
+
+        blitStream->setSrcBuffer((void**)planar, (unsigned int*)length, 3);
+        //blitStream->setSrcConfig(srcWStride, srcHStride, eYV12, eInterlace_None, &srcRoi);
+        blitStream->setSrcConfig(srcWStride, srcHStride, srcWStride, (((srcWStride>>1)+0xf) & (~0xf)), eYV12, DP_PROFILE_BT601, eInterlace_None, &srcRoi);
+    }
+    else if (mSrcFormat == OMX_COLOR_Format32bitARGB8888) {
+        char* planar[1];
+        unsigned int length[1];
+        planar[0] = (char*)src.mBits;
+        length[0] = srcWStride*srcHStride*4;
+        blitStream->setSrcBuffer((void**)planar, (unsigned int*)length, 1);
+        blitStream->setSrcConfig(srcWStride, srcHStride, eRGBA8888, eInterlace_None, &srcRoi);
+    }
+    else if (mSrcFormat == OMX_COLOR_FormatVendorMTKYUV) {
+        char* planar[2];
+        unsigned int length[2];
+        planar[0] = (char*)src.mBits;
+        length[0] = srcWStride*srcHStride;
+        planar[1] = planar[0] + length[0];
+        length[1] = srcWStride*srcHStride/2;
+        ALOGD("Yaddr(%p), Caddr(%p)", planar[0], planar[1]);
+        ALOGD("Ylen(%d), Clen(%d)", length[0], length[1]);
+
+        blitStream->setSrcBuffer((void**)planar, (unsigned int*)length, 2);
+        //blitStream->setSrcConfig(srcWStride, srcHStride, eNV12_BLK, eInterlace_None, &srcRoi);
+        blitStream->setSrcConfig(srcWStride, srcHStride, srcWStride * 32, srcWStride * 16, eNV12_BLK, DP_PROFILE_BT601, eInterlace_None, &srcRoi);
+    }
+    else if (mSrcFormat == OMX_COLOR_FormatVendorMTKYUV_FCM) {
+        char* planar[2];
+        unsigned int length[2];
+        planar[0] = (char*)src.mBits;
+        length[0] = srcWStride*srcHStride;
+        planar[1] = planar[0] + length[0];
+        length[1] = srcWStride*srcHStride/2;
+        ALOGD("Yaddr(%p), Caddr(%p)", planar[0], planar[1]);
+        ALOGD("Ylen(%d), Clen(%d)", length[0], length[1]);
+
+        blitStream->setSrcBuffer((void**)planar, (unsigned int*)length, 2);
+        //blitStream->setSrcConfig(srcWStride, srcHStride, eNV12_BLK_FCM, eInterlace_None, &srcRoi);
+        blitStream->setSrcConfig(srcWStride, srcHStride, srcWStride * 32, srcWStride * 16, eNV12_BLK_FCM, DP_PROFILE_BT601, eInterlace_None, &srcRoi);
+    }
+    ALOGD("dst addr(%p), w(%d), h(%d)", dst.mBits, dstWStride, dstHStride);
+    if (mDstFormat == OMX_COLOR_Format16bitRGB565) {
+        blitStream->setDstBuffer(dst.mBits, dst.mWidth * dst.mHeight * 2);
+        blitStream->setDstConfig(dst.mWidth, dst.mHeight, eRGB565);
+    }
+    else if (mDstFormat == OMX_COLOR_Format32bitARGB8888) {
+        blitStream->setDstBuffer(dst.mBits, dst.mWidth * dst.mHeight * 4);
+        //blitStream->setDstConfig(dst.mWidth, dst.mHeight, eARGB8888);
+        blitStream->setDstConfig(dst.mWidth, dst.mHeight, eRGBA8888);
+    }
+
+    sprintf(name_yuv, "/sdcard/retriever_%" PRId64 "_%zu_%zu.yuv",systemTime(),src.mWidth,src.mHeight);
+    sprintf(retriever_yuv_propty, "retriever.dump.yuv");
+    dumpColorConverterData(name_yuv,src.mBits,(src.mWidth*src.mHeight)*2,retriever_yuv_propty);
+
+    //Add Sharpness in Video Thumbnail
+    blitStream->setTdshp(1);
+    bool bRet = blitStream->invalidate();
+    ALOGI("blitStream return %d.", bRet);
+
+    sprintf(name_rgb, "/sdcard/retriever_%" PRId64 "_%zu_%zu.rgb",systemTime(),dst.mWidth,dst.mHeight);
+    sprintf(retriever_propty_rgb, "retriever.dump.rgb");
+    if (mDstFormat == OMX_COLOR_Format16bitRGB565){
+        dumpColorConverterData(name_rgb,dst.mBits, dst.mWidth*dst.mHeight*2, retriever_propty_rgb);
+    }else if(mDstFormat == OMX_COLOR_Format32bitARGB8888){
+        dumpColorConverterData(name_rgb,dst.mBits, dst.mWidth*dst.mHeight*4, retriever_propty_rgb);
+    }
+
+    if(!bRet)
+        return OK;
+    else
+        return UNKNOWN_ERROR;
+
+    return OK;
+}
+
+void ColorConverter::dumpColorConverterData(const char * filepath, const void * buffer, size_t size,const char * propty) {
+
+    char value[PROPERTY_VALUE_MAX];
+    property_get(propty, value, "0");
+    int bflag=atoi(value);
+
+    if (bflag) {
+       FILE * fp= fopen (filepath, "w");
+       if (fp!=NULL) {
+            fwrite(buffer,size,1,fp);
+            fclose(fp);
+       } else {
+            ALOGV("dump %s fail",propty);
+       }
+    }
+}
+#endif
+
 }  // namespace android
diff --git a/media/libstagefright/colorconversion/inc/DpBlitStream.h b/media/libstagefright/colorconversion/inc/DpBlitStream.h
new file mode 100644
index 0000000000..cad8f5b4b9
--- /dev/null
+++ b/media/libstagefright/colorconversion/inc/DpBlitStream.h
@@ -0,0 +1,209 @@
+#ifndef __DP_BLIT_STREAM_H__
+#define __DP_BLIT_STREAM_H__
+
+#include "DpDataType.h"
+
+
+class DpBlitStream
+{
+public:
+    static bool queryHWSupport(uint32_t         srcWidth,
+                               uint32_t         srcHeight,
+                               uint32_t         dstWidth,
+                               uint32_t         dstHeight,
+                               int32_t          Orientation = 0,
+                               DpColorFormat    srcFormat = DP_COLOR_UNKNOWN,
+                               DpColorFormat    dstFormat = DP_COLOR_UNKNOWN);
+
+    DpBlitStream();
+
+    ~DpBlitStream();
+
+    enum DpOrientation
+    {
+        ROT_0   = 0x00000000,
+        FLIP_H  = 0x00000001,
+        FLIP_V  = 0x00000002,
+        ROT_90  = 0x00000004,
+        ROT_180 = FLIP_H|FLIP_V,
+        ROT_270 = ROT_180|ROT_90,
+        ROT_INVALID = 0x80
+    };
+
+    DP_STATUS_ENUM setSrcBuffer(void     *pVABase,
+                                uint32_t size);
+
+    DP_STATUS_ENUM setSrcBuffer(void     **pVAList,
+                                uint32_t *pSizeList,
+                                uint32_t planeNumber);
+
+    // VA + MVA address interface
+    DP_STATUS_ENUM setSrcBuffer(void**   pVAddrList,
+                                void**   pMVAddrList,
+                                uint32_t *pSizeList,
+                                uint32_t planeNumber);
+
+    // for ION file descriptor
+    DP_STATUS_ENUM setSrcBuffer(int32_t  fileDesc,
+                                uint32_t *sizeList,
+                                uint32_t planeNumber);
+
+    DP_STATUS_ENUM setSrcConfig(int32_t           width,
+                                int32_t           height,
+                                DpColorFormat     format,
+                                DpInterlaceFormat field = eInterlace_None,
+                                DpRect            *pROI = 0);
+
+    DP_STATUS_ENUM setSrcConfig(int32_t           width,
+                                int32_t           height,
+                                int32_t           yPitch,
+                                int32_t           uvPitch,
+                                DpColorFormat     format,
+                                DP_PROFILE_ENUM   profile = DP_PROFILE_BT601,
+                                DpInterlaceFormat field   = eInterlace_None,
+                                DpRect            *pROI   = 0,
+                                DpSecure          secure  = DP_SECURE_NONE,
+                                bool              doFlush = true);
+
+    DP_STATUS_ENUM setDstBuffer(void     *pVABase,
+                                uint32_t size);
+
+    DP_STATUS_ENUM setDstBuffer(void     **pVABaseList,
+                                uint32_t *pSizeList,
+                                uint32_t planeNumber);
+
+    // VA + MVA address interface
+    DP_STATUS_ENUM setDstBuffer(void**   pVABaseList,
+                                void**   pMVABaseList,
+                                uint32_t *pSizeList,
+                                uint32_t planeNumber);
+
+    // for ION file descriptor
+    DP_STATUS_ENUM setDstBuffer(int32_t  fileDesc,
+                                uint32_t *pSizeList,
+                                uint32_t planeNumber);
+
+    DP_STATUS_ENUM setDstConfig(int32_t           width,
+                                int32_t           height,
+                                DpColorFormat     format,
+                                DpInterlaceFormat field = eInterlace_None,
+                                DpRect            *pROI = 0);
+
+    DP_STATUS_ENUM setDstConfig(int32_t           width,
+                                int32_t           height,
+                                int32_t           yPitch,
+                                int32_t           uvPitch,
+                                DpColorFormat     format,
+                                DP_PROFILE_ENUM   profile = DP_PROFILE_BT601,
+                                DpInterlaceFormat field   = eInterlace_None,
+                                DpRect            *pROI   = 0,
+                                DpSecure          secure  = DP_SECURE_NONE,
+                                bool              doFlush = true);
+
+    DP_STATUS_ENUM setRotate(int32_t rotation)
+    {
+        if (m_rotation != rotation)
+        {
+            m_rotation = rotation;
+            m_frameChange = true;
+        }
+
+        return DP_STATUS_RETURN_SUCCESS;
+    }
+
+    //Compatible to 89
+    DP_STATUS_ENUM setFlip(int flip)
+    {
+        if (m_flipStatus != flip)
+        {
+            m_flipStatus = flip ? true : false;
+            m_frameChange = true;
+        }
+
+        return DP_STATUS_RETURN_SUCCESS;
+    }
+
+    DP_STATUS_ENUM setOrientation(uint32_t transform);
+
+    DP_STATUS_ENUM setTdshp(int gain)
+    {
+        if (mTdshp != gain)
+        {
+            mTdshp        = gain;
+            m_frameChange = true;
+        }
+
+        return DP_STATUS_RETURN_SUCCESS;
+    }
+
+    uint32_t getPqID();
+
+    DP_STATUS_ENUM setPQParameter(const DpPqParam &pParam);
+
+    DP_STATUS_ENUM setDither(bool enDither)
+    {
+        if (m_ditherStatus != enDither)
+        {
+            m_ditherStatus = enDither;
+            m_frameChange  = true;
+        }
+
+        return DP_STATUS_RETURN_SUCCESS;
+    }
+
+    DP_STATUS_ENUM setUser(uint32_t eID = 0);
+
+    DP_STATUS_ENUM invalidate();
+
+    DP_STATUS_ENUM pq_process();
+
+private:
+    DpStream          *m_pStream;
+    DpChannel         *m_pChannel;
+    int32_t           m_channelID;
+    DpBasicBufferPool *m_pSrcPool;
+    DpBasicBufferPool *m_pDstPool;
+    int32_t           m_srcBuffer;
+    int32_t           m_srcWidth;
+    int32_t           m_srcHeight;
+    int32_t           m_srcYPitch;
+    int32_t           m_srcUVPitch;
+    DpColorFormat     m_srcFormat;
+    DP_PROFILE_ENUM   m_srcProfile;
+    DpSecure          m_srcSecure;
+    bool              m_srcFlush;
+    int32_t           m_dstBuffer;
+    int32_t           m_dstWidth;
+    int32_t           m_dstHeight;
+    int32_t           m_dstYPitch;
+    int32_t           m_dstUVPitch;
+    DpColorFormat     m_dstFormat;
+    DP_PROFILE_ENUM   m_dstProfile;
+    DpSecure          m_dstSecure;
+    bool              m_dstFlush;
+    DpStream          *m_pPqStream;
+    DpChannel         *m_pPqChannel;
+    DpAutoBufferPool  *m_pPqPool;
+    int32_t           m_pqBuffer;
+    int32_t           m_cropXStart;
+    int32_t           m_cropYStart;
+    int32_t           m_cropWidth;
+    int32_t           m_cropHeight;
+    int32_t           m_cropSubPixelX;
+    int32_t           m_cropSubPixelY;
+    int32_t           m_targetXStart;
+    int32_t           m_targetYStart;
+    int32_t           m_rotation;
+    bool              m_frameChange;
+    bool              m_flipStatus;
+    bool              m_ditherStatus;
+    DpBlitUser        m_userID;
+    DpPqConfig        m_PqConfig;
+    uint32_t          m_PqID;
+    int32_t           m_pqSupport;
+    uint32_t          m_engFlag;
+    //Compatible to 89
+    int               mTdshp;
+};
+
+#endif  // __DP_BLIT_STREAM_H__
diff --git a/media/libstagefright/colorconversion/inc/DpConfig.h b/media/libstagefright/colorconversion/inc/DpConfig.h
new file mode 100644
index 0000000000..f41078509c
--- /dev/null
+++ b/media/libstagefright/colorconversion/inc/DpConfig.h
@@ -0,0 +1,24 @@
+#ifndef __DP_CONFIG_H__
+#define __DP_CONFIG_H__
+
+#define CONFIG_FOR_OS_WINDOWS       0
+
+#define CONFIG_FOR_OS_ANDROID       1
+
+#if !(CONFIG_FOR_OS_WINDOWS ^ CONFIG_FOR_OS_ANDROID)
+    #error "Please specify the correct platform"
+#endif
+
+#define CONFIG_FOR_TPIPE_FINFO      0
+
+#define CONFIG_FOR_PROFILE_INFO     0
+
+#define CONFIG_FOR_DUMP_COMMAND     0
+
+#define CONFIG_FOR_FLUSH_RANGE      0
+
+#define CONFIG_FOR_VERIFY_FPGA      0
+
+#define CONFIG_FOR_SYSTRACE         0
+
+#endif  // __DP_CONFIG_H__
diff --git a/media/libstagefright/colorconversion/inc/DpDataType.h b/media/libstagefright/colorconversion/inc/DpDataType.h
new file mode 100644
index 0000000000..a619bc845c
--- /dev/null
+++ b/media/libstagefright/colorconversion/inc/DpDataType.h
@@ -0,0 +1,631 @@
+#ifndef __DP_DATA_TYPE_H__
+#define __DP_DATA_TYPE_H__
+
+#ifndef __KERNEL__
+#include "DpConfig.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <assert.h>
+#include <string.h>
+#include <math.h>
+#endif
+#if CONFIG_FOR_OS_WINDOWS
+    #include <stddef.h>
+    typedef signed char     int8_t;
+    typedef unsigned char   uint8_t;
+    typedef signed short    int16_t;
+    typedef unsigned short  uint16_t;
+    typedef signed int      int32_t;
+    typedef unsigned int    uint32_t;
+    typedef signed long long     int64_t;
+    typedef unsigned long long   uint64_t;
+#ifndef __unused
+    #define __unused
+#endif
+
+inline float roundf(float x)
+{
+    float t;
+
+    if (x >= 0.0) {
+        t = floorf(x);
+        if (t - x <= -0.5)
+            t += 1.0;
+        return (t);
+    } else {
+        t = floorf(-x);
+        if (t + x <= -0.5)
+            t += 1.0;
+        return (-t);
+    }
+}
+#endif  // CONFIG_FOR_OS_WINDOWS
+
+#ifndef MAX
+    #define MAX(x, y)   ((x) >= (y))? (x): (y)
+#endif // MAX
+
+#ifndef MIN
+    #define MIN(x, y)   ((x) <= (y))? (x): (y)
+#endif  // MIN
+
+#ifndef __KERNEL__
+class DpStream;
+class DpChannel;
+
+class DpBasicBufferPool;
+class DpAutoBufferPool;
+class DpCommand;
+#endif
+
+typedef unsigned long long DpJobID;
+typedef int DpEngineType;
+
+typedef enum DP_STATUS_ENUM
+{
+    DP_STATUS_ABORTED_BY_USER   =  4,
+    DP_STATUS_ALL_TEST_DONE     =  3,
+    DP_STATUS_ALL_TPIPE_DONE    =  2,
+    DP_STATUS_BUFFER_DONE       =  1,
+    DP_STATUS_RETURN_SUCCESS    =  0,
+    DP_STATUS_INVALID_PARAX     = -1,
+    DP_STATUS_INVALID_PORT      = -2,
+    DP_STATUS_INVALID_PATH      = -3,
+    DP_STATUS_INVALID_FILE      = -4,
+    DP_STATUS_INVALID_CHANNEL   = -5,
+    DP_STATUS_INVALID_BUFFER    = -6,
+    DP_STATUS_INVALID_STATE     = -7,
+    DP_STATUS_INVALID_ENGINE    = -8,
+    DP_STATUS_INVALID_FORMAT    = -9,
+    DP_STATUS_INVALID_X_INPUT   = -10,
+    DP_STATUS_INVALID_Y_INPUT   = -11,
+    DP_STATUS_INVALID_X_OUTPUT  = -12,
+    DP_STATUS_INVALID_Y_OUTPUT  = -13,
+    DP_STATUS_INVALID_X_ALIGN   = -14,
+    DP_STATUS_INVALID_Y_ALIGN   = -15,
+    DP_STATUS_INVALID_WIDTH     = -16,
+    DP_STATUS_INVALID_HEIGHT    = -17,
+    DP_STATUS_INVALID_CROP      = -18,
+    DP_STATUS_INVALID_ANGLE     = -19,
+    DP_STATUS_INVALID_EVENT     = -20,
+    DP_STATUS_INVALID_OPCODE    = -21,
+    DP_STATUS_CAN_NOT_MERGE     = -22,
+    DP_STATUS_OUT_OF_MEMORY     = -23,
+    DP_STATUS_BUFFER_FULL       = -24,
+    DP_STATUS_BUFFER_EMPTY      = -25,
+    DP_STATUS_OPERATION_FAILED  = -26,
+    DP_STATUS_OVER_MAX_BRANCH   = -27,
+    DP_STATUS_OVER_MAX_ENGINE   = -28,
+    DP_STATUS_OVER_MAX_BACKUP   = -29,
+    DP_STATUS_SCHEDULE_ERROR    = -30,
+    DP_STATUS_OVER_MAX_WIDTH    = -31,
+    DP_STATUS_OVER_MAX_HEIGHT   = -32,
+    DP_STATUS_LEFT_EDGE_ERROR   = -33,
+    DP_STATUS_RIGHT_EDGE_ERROR  = -34,
+    DP_STATUS_TOP_EDGE_ERROR    = -35,
+    DP_STATUS_BOTTOM_EDGE_ERROR = -36,
+    DP_STATUS_X_LESS_THAN_LAST  = -37,
+    DP_STATUS_Y_LESS_THAN_LAST  = -38,
+    DP_STATUS_UNWANTED_X_CAL    = -39,
+    DP_STATUS_LOSS_OVER_WIDTH   = -40,
+    DP_STATUS_LOSS_OVER_HEIGHT  = -41,
+    DP_STATUS_X_ALIGN_ERROR     = -42,
+    DP_STATUS_Y_ALIGN_ERROR     = -43,
+    DP_STATUS_X_OUT_OVERLAP     = -44,
+    DP_STATUS_Y_OUT_OVERLAP     = -45,
+    DP_STATUS_BACK_LE_FORWARD   = -46,
+    DP_STATUS_UNKNOWN_ERROR     = -47,
+} DP_STATUS_ENUM;
+
+
+typedef enum DP_MEMORY_ENUM
+{
+    DP_MEMORY_VA,
+    DP_MEMORY_ION,
+    DP_MEMORY_PHY,
+    DP_MEMORY_MVA
+} DP_MEMORY_ENUM;
+
+typedef struct DpJPEGEnc_Config_st // for JPEG port only
+{
+    int32_t     fileDesc;
+    uint32_t    size;
+    uint32_t    fQuality;
+    uint32_t    soi_en;
+    void        *memSWAddr[3];
+} DpJPEGEnc_Config;
+
+typedef struct DpVEnc_Config // for VENC port only
+{
+    /* Venc Modify + */
+    unsigned long rVencDrvHandle;
+    /* Venc Modify - */
+    uint32_t    memYUVMVAAddr[3];
+    uint32_t    memYUVMVASize[3];
+    void        *memYUVSWAddr[3];
+    void        *memOutputSWAddr[3];
+
+    uint32_t*   pNumPABuffer;
+    uint32_t*   pPABuffer;
+    uint64_t*   pConfigFrameCount;
+    uint64_t*   pDequeueFrameCount;
+    DpCommand*  pVEncCommander;
+} DpVEnc_Config;
+
+
+#ifndef __KERNEL__
+class DpRect
+{
+public:
+
+    enum
+    {
+        eINVALID_VALUE = -1,
+        eINITIAL_VALUE = 0   //TBD, why to set as "0"?
+    };
+
+    inline DpRect(void)
+        : x(eINITIAL_VALUE), sub_x(eINITIAL_VALUE),
+          y(eINITIAL_VALUE), sub_y(eINITIAL_VALUE),
+          w(eINITIAL_VALUE), h(eINITIAL_VALUE)
+    {}
+
+    inline DpRect(int32_t in_x, int32_t in_y, int32_t in_w, int32_t in_h,
+                  int32_t in_sub_x = 0, int32_t in_sub_y = 0)
+        : x(in_x),
+          sub_x(in_sub_x),
+          y(in_y),
+          sub_y(in_sub_y),
+          w(in_w),
+          h(in_h)
+    {}
+
+    inline DpRect(const DpRect& rt)
+        : x(rt.x),
+          sub_x(rt.sub_x),
+          y(rt.y),
+          sub_y(rt.sub_y),
+          w(rt.w),
+          h(rt.h)
+    {}
+
+    ~DpRect(void) {}
+
+    inline DpRect& operator= (const DpRect& rval)
+    {
+        if (this != &rval)
+        {
+            x = rval.x;
+            sub_x = rval.sub_x;
+            y = rval.y;
+            sub_y = rval.sub_y;
+            w = rval.w;
+            h = rval.h;
+        }
+
+        return *this;
+    }
+
+    int32_t x;
+    int32_t sub_x;
+    int32_t y;
+    int32_t sub_y;
+    int32_t w;
+    int32_t h;
+};
+#endif
+
+class DpColorMatrix
+{
+    /* Define the color matrix.
+     *
+     * Color matrix would be used in the following transforms:
+     * YUV2RGB
+     * / R \   / c00 c01 c02 \   / Y - i0 \
+     * | G | = | c10 c11 c12 | * | U - i1 |
+     * \ B /   \ c20 c21 c22 /   \ V - i2 /
+     * YUV2YUV
+     * / Y \   / c00 c01 c02 \   / Y - i0 \   / o0 \
+     * | U | = | c10 c11 c12 | * | U - i1 | + | o1 |
+     * \ V /   \ c20 c21 c22 /   \ V - i2 /   \ o2 /
+     *
+     * Coefficient value range: -4.00 ~ 3.99
+     */
+
+public:
+    bool enable;
+    float c00; float c01; float c02;
+    float c10; float c11; float c12;
+    float c20; float c21; float c22;
+
+    inline DpColorMatrix(void)
+        : enable(false),
+          c00(1.0), c01(0.0), c02(0.0),
+          c10(0.0), c11(1.0), c12(0.0),
+          c20(0.0), c21(0.0), c22(1.0)
+    {}
+
+    inline DpColorMatrix(float in_c00, float in_c01, float in_c02,
+                         float in_c10, float in_c11, float in_c12,
+                         float in_c20, float in_c21, float in_c22,
+                         bool in_enable = true)
+        : enable(in_enable),
+          c00(in_c00), c01(in_c01), c02(in_c02),
+          c10(in_c10), c11(in_c11), c12(in_c12),
+          c20(in_c20), c21(in_c21), c22(in_c22)
+    {}
+
+    inline DpColorMatrix(const DpColorMatrix& m)
+        : enable(m.enable),
+          c00(m.c00), c01(m.c01), c02(m.c02),
+          c10(m.c10), c11(m.c11), c12(m.c12),
+          c20(m.c20), c21(m.c21), c22(m.c22)
+    {}
+
+    ~DpColorMatrix(void) {}
+
+    inline DpColorMatrix& operator= (const DpColorMatrix& r)
+    {
+        if (this != &r)
+        {
+            enable = r.enable;
+            c00 = r.c00; c01 = r.c01; c02 = r.c02;
+            c10 = r.c10; c11 = r.c11; c12 = r.c12;
+            c20 = r.c20; c21 = r.c21; c22 = r.c22;
+        }
+
+        return *this;
+    }
+
+    inline DpColorMatrix operator* (const DpColorMatrix& r)
+    {
+        if (!enable)
+        {
+            if (!r.enable)
+            {
+                return DpColorMatrix();
+            }
+            return DpColorMatrix(r);
+        }
+        if (!r.enable)
+        {
+            return DpColorMatrix(*this);
+        }
+
+        return DpColorMatrix(
+            c00 * r.c00 + c01 * r.c10 + c02 * r.c20, c00 * r.c01 + c01 * r.c11 + c02 * r.c21, c00 * r.c02 + c01 * r.c12 + c02 * r.c22,
+            c10 * r.c00 + c11 * r.c10 + c12 * r.c20, c10 * r.c01 + c11 * r.c11 + c12 * r.c21, c10 * r.c02 + c11 * r.c12 + c12 * r.c22,
+            c20 * r.c00 + c21 * r.c10 + c22 * r.c20, c20 * r.c01 + c21 * r.c11 + c22 * r.c21, c20 * r.c02 + c21 * r.c12 + c22 * r.c22);
+    }
+
+    inline bool operator== (const DpColorMatrix& r)
+    {
+        if (this == &r)
+        {
+            return true;
+        }
+        if (!enable && !r.enable)
+        {
+            return true;
+        }
+        return (enable == r.enable) &&
+            (c00 == r.c00) && (c01 == r.c01) && (c02 == r.c02) &&
+            (c10 == r.c10) && (c11 == r.c11) && (c12 == r.c12) &&
+            (c20 == r.c20) && (c21 == r.c21) && (c22 == r.c22);
+    }
+
+    inline bool operator!= (const DpColorMatrix& r)
+    {
+        return !(*this == r);
+    }
+};
+
+inline DpColorMatrix operator* (const float l, const DpColorMatrix& r)
+{
+    return DpColorMatrix(
+        l * r.c00, l * r.c01, l * r.c02,
+        l * r.c10, l * r.c11, l * r.c12,
+        l * r.c20, l * r.c21, l * r.c22,
+        r.enable);
+}
+
+
+typedef enum DP_PROFILE_ENUM
+{
+    DP_PROFILE_BT601, //Limited range
+    DP_PROFILE_BT709,
+    DP_PROFILE_JPEG,
+    DP_PROFILE_FULL_BT601 = DP_PROFILE_JPEG
+} DP_PROFILE_ENUM;
+
+
+typedef enum DP_STREAM_ID_ENUM
+{
+    DP_BLITSTREAM       = 0x10000000,
+    DP_FRAGSTREAM       = 0x20000000,
+    DP_ISPSTREAM        = 0x30000000,
+    DP_ASYNCBLITSTREAM  = 0x40000000,
+    DP_VENCSTREAM       = 0x50000000,
+    DP_UNKNOWN_STREAM   = 0xF0000000,
+} DP_STREAM_ID_ENUM;
+
+typedef enum DP_MEDIA_TYPE_ENUM
+{
+    MEDIA_UNKNOWN,
+    MEDIA_VIDEO,
+    MEDIA_PICTURE,
+    MEDIA_ISP_PREVIEW
+} DP_MEDIA_TYPE_ENUM;
+
+typedef struct
+{
+    uint32_t id;
+    uint32_t timeStamp;
+    uint32_t reserved[28];   // padding and reserved
+} DpVideoParam;
+
+typedef struct
+{
+    bool withHist;
+    uint32_t info[20];
+    uint32_t iso;
+    uint32_t reserved[8];  // padding and reserved
+} DpImageParam;
+
+typedef struct
+{
+    uint32_t iso;
+    uint32_t reserved[29];
+} DpIspParam;
+
+
+struct DpPqParam {
+    bool enable;
+    DP_MEDIA_TYPE_ENUM scenario;
+
+    union {
+        DpVideoParam video;
+        DpImageParam image;
+        DpIspParam isp;
+    } u;
+};
+
+struct DpPqConfig {
+    uint32_t enSharp;
+    uint32_t enDC;
+    uint32_t enColor;
+};
+
+
+// Format group: 0-RGB, 1-YUV, 2-Bayer raw, 3-compressed format
+#define DP_COLORFMT_PACK(PACKED, LOOSE, VIDEO, PLANE, COPLANE, HFACTOR, VFACTOR, BITS, GROUP ,SWAP_ENABLE, UNIQUEID)  \
+    ((PACKED        << 31) |                                                             \
+     (LOOSE         << 30) |                                                             \
+     (VIDEO         << 27) |                                                             \
+     (PLANE         << 24) |                                                             \
+     (COPLANE       << 22) |                                                             \
+     (HFACTOR       << 20) |                                                             \
+     (VFACTOR       << 18) |                                                             \
+     (BITS          << 8)  |                                                             \
+     (GROUP         << 6)  |                                                             \
+     (SWAP_ENABLE   << 5)  |                                                             \
+     (UNIQUEID      << 0))
+
+#define DP_COLOR_GET_10BIT_PACKED(color)        ((0x80000000 & color) >> 31)
+#define DP_COLOR_GET_10BIT_LOOSE(color)        (((0xC0000000 & color) >> 30) == 1)
+#define DP_COLOR_GET_10BIT_TILE_MODE(color)    (((0xC0000000 & color) >> 30) == 3)
+#define DP_COLOR_GET_UFP_ENABLE(color)          ((0x20000000 & color) >> 29)
+#define DP_COLOR_GET_INTERLACED_MODE(color)     ((0x10000000 & color) >> 28)
+#define DP_COLOR_GET_BLOCK_MODE(color)          ((0x08000000 & color) >> 27)
+#define DP_COLOR_GET_PLANE_COUNT(color)         ((0x07000000 & color) >> 24)
+#define DP_COLOR_IS_UV_COPLANE(color)           ((0x00C00000 & color) >> 22)
+#define DP_COLOR_GET_H_SUBSAMPLE(color)         ((0x00300000 & color) >> 20)
+#define DP_COLOR_GET_V_SUBSAMPLE(color)         ((0x000C0000 & color) >> 18)
+#define DP_COLOR_BITS_PER_PIXEL(color)          ((0x0003FF00 & color) >>  8)
+#define DP_COLOR_GET_COLOR_GROUP(color)         ((0x000000C0 & color) >>  6)
+#define DP_COLOR_GET_SWAP_ENABLE(color)         ((0x00000020 & color) >>  5)
+#define DP_COLOR_GET_UNIQUE_ID(color)           ((0x0000001F & color) >>  0)
+#define DP_COLOR_GET_HW_FORMAT(color)           ((0x0000001F & color) >>  0)
+
+typedef enum DP_COLOR_ENUM
+{
+    DP_COLOR_UNKNOWN        = 0,
+    DP_COLOR_FULLG8         = DP_COLORFMT_PACK(0, 0,  0,   1,  0, 0, 0,  8, 3,  0, 20),
+    DP_COLOR_FULLG10        = DP_COLORFMT_PACK(0, 0,  0,   1,  0, 0, 0, 10, 3,  0, 21),
+    DP_COLOR_FULLG12        = DP_COLORFMT_PACK(0, 0,  0,   1,  0, 0, 0, 12, 3,  0, 22),
+    DP_COLOR_FULLG14        = DP_COLORFMT_PACK(0, 0,  0,   1,  0, 0, 0, 14, 3,  0, 26),
+    DP_COLOR_UFO10          = DP_COLORFMT_PACK(0, 0,  0,   1,  0, 0, 0, 10, 3,  0, 27),
+
+    DP_COLOR_BAYER8         = DP_COLORFMT_PACK(0, 0,  0,   1,  0, 0, 0,  8, 2,  0, 20),
+    DP_COLOR_BAYER10        = DP_COLORFMT_PACK(0, 0,  0,   1,  0, 0, 0, 10, 2,  0, 21),
+    DP_COLOR_BAYER12        = DP_COLORFMT_PACK(0, 0,  0,   1,  0, 0, 0, 12, 2,  0, 22),
+
+    DP_COLOR_RGB48          = DP_COLORFMT_PACK(0, 0,  0,   1,  0, 0, 0, 48, 2,  0, 23),
+    DP_COLOR_RGB565_RAW     = DP_COLORFMT_PACK(0, 0,  0,   1,  0, 0, 0, 16, 2,  0, 0),//for Bayer+Mono raw-16
+
+    // Unified format
+    DP_COLOR_GREY           = DP_COLORFMT_PACK(0, 0,  0,   1,  0, 0, 0,  8, 1,  0, 7),
+
+    DP_COLOR_RGB565         = DP_COLORFMT_PACK(0, 0,  0,   1,  0, 0, 0, 16, 0,  0, 0),
+    DP_COLOR_BGR565         = DP_COLORFMT_PACK(0, 0,  0,   1,  0, 0, 0, 16, 0,  1, 0),
+    DP_COLOR_RGB888         = DP_COLORFMT_PACK(0, 0,  0,   1,  0, 0, 0, 24, 0,  1, 1),
+    DP_COLOR_BGR888         = DP_COLORFMT_PACK(0, 0,  0,   1,  0, 0, 0, 24, 0,  0, 1),
+    DP_COLOR_RGBA8888       = DP_COLORFMT_PACK(0, 0,  0,   1,  0, 0, 0, 32, 0,  1, 2),
+    DP_COLOR_BGRA8888       = DP_COLORFMT_PACK(0, 0,  0,   1,  0, 0, 0, 32, 0,  0, 2),
+    DP_COLOR_ARGB8888       = DP_COLORFMT_PACK(0, 0,  0,   1,  0, 0, 0, 32, 0,  1, 3),
+    DP_COLOR_ABGR8888       = DP_COLORFMT_PACK(0, 0,  0,   1,  0, 0, 0, 32, 0,  0, 3),
+
+    DP_COLOR_UYVY           = DP_COLORFMT_PACK(0, 0,  0,   1,  0, 1, 0, 16, 1,  0, 4),
+    DP_COLOR_VYUY           = DP_COLORFMT_PACK(0, 0,  0,   1,  0, 1, 0, 16, 1,  1, 4),
+    DP_COLOR_YUYV           = DP_COLORFMT_PACK(0, 0,  0,   1,  0, 1, 0, 16, 1,  0, 5),
+    DP_COLOR_YVYU           = DP_COLORFMT_PACK(0, 0,  0,   1,  0, 1, 0, 16, 1,  1, 5),
+
+    DP_COLOR_I420           = DP_COLORFMT_PACK(0, 0,  0,   3,  0, 1, 1,  8, 1,  0, 8),
+    DP_COLOR_YV12           = DP_COLORFMT_PACK(0, 0,  0,   3,  0, 1, 1,  8, 1,  1, 8),
+    DP_COLOR_I422           = DP_COLORFMT_PACK(0, 0,  0,   3,  0, 1, 0,  8, 1,  0, 9),
+    DP_COLOR_YV16           = DP_COLORFMT_PACK(0, 0,  0,   3,  0, 1, 0,  8, 1,  1, 9),
+    DP_COLOR_I444           = DP_COLORFMT_PACK(0, 0,  0,   3,  0, 0, 0,  8, 1,  0, 10),
+    DP_COLOR_YV24           = DP_COLORFMT_PACK(0, 0,  0,   3,  0, 0, 0,  8, 1,  1, 10),
+
+    DP_COLOR_NV12           = DP_COLORFMT_PACK(0, 0,  0,   2,  1, 1, 1,  8, 1,  0, 12),
+    DP_COLOR_NV21           = DP_COLORFMT_PACK(0, 0,  0,   2,  1, 1, 1,  8, 1,  1, 12),
+    DP_COLOR_NV16           = DP_COLORFMT_PACK(0, 0,  0,   2,  1, 1, 0,  8, 1,  0, 13),
+    DP_COLOR_NV61           = DP_COLORFMT_PACK(0, 0,  0,   2,  1, 1, 0,  8, 1,  1, 13),
+    DP_COLOR_NV24           = DP_COLORFMT_PACK(0, 0,  0,   2,  1, 0, 0,  8, 1,  0, 14),
+    DP_COLOR_NV42           = DP_COLORFMT_PACK(0, 0,  0,   2,  1, 0, 0,  8, 1,  1, 14),
+
+    // Mediatek proprietary format
+    DP_COLOR_420_BLKP_UFO   = DP_COLORFMT_PACK(0, 0,  5,   2,  1, 1, 1, 256, 1, 0, 12),//Frame mode + Block mode
+    DP_COLOR_420_BLKP       = DP_COLORFMT_PACK(0, 0,  1,   2,  1, 1, 1, 256, 1, 0, 12),//Frame mode + Block mode
+    DP_COLOR_420_BLKI       = DP_COLORFMT_PACK(0, 0,  3,   2,  1, 1, 1, 256, 1, 0, 12),//Field mode + Block mode
+    DP_COLOR_422_BLKP       = DP_COLORFMT_PACK(0, 0,  1,   1,  0, 1, 0, 512, 1, 0, 4), //Frame mode
+
+    DP_COLOR_PARGB8888      = DP_COLORFMT_PACK(0, 0,  0,   1,  0, 0, 0, 32,  0, 0, 26),
+    DP_COLOR_XARGB8888      = DP_COLORFMT_PACK(0, 0,  0,   1,  0, 0, 0, 32,  0, 0, 27),
+    DP_COLOR_PABGR8888      = DP_COLORFMT_PACK(0, 0,  0,   1,  0, 0, 0, 32,  0, 0, 28),
+    DP_COLOR_XABGR8888      = DP_COLORFMT_PACK(0, 0,  0,   1,  0, 0, 0, 32,  0, 0, 29),
+
+    DP_COLOR_IYU2           = DP_COLORFMT_PACK(0, 0,  0,   1,  0, 0, 0, 24,  1, 0, 25),
+    DP_COLOR_YUV444         = DP_COLORFMT_PACK(0, 0,  0,   1,  0, 0, 0, 24,  1, 0, 30),
+
+    // Mediatek proprietary 10bit format
+    DP_COLOR_RGBA1010102    = DP_COLORFMT_PACK(1, 0,  0,   1,  0, 0, 0, 32,  0, 1, 2),
+    DP_COLOR_BGRA1010102    = DP_COLORFMT_PACK(1, 0,  0,   1,  0, 0, 0, 32,  0, 0, 2),
+    DP_COLOR_UYVY_10P       = DP_COLORFMT_PACK(1, 0,  0,   1,  0, 1, 0, 20,  1, 0, 4),//Packed 10bit UYVY
+    DP_COLOR_NV21_10P       = DP_COLORFMT_PACK(1, 0,  0,   2,  1, 1, 1, 10,  1, 1, 12),//Packed 10bit NV21
+    DP_COLOR_420_BLKP_10_H  = DP_COLORFMT_PACK(1, 0,  1,   2,  1, 1, 1, 320, 1, 0, 12),//Frame mode + Block mode
+    DP_COLOR_420_BLKP_10_V  = DP_COLORFMT_PACK(1, 1,  1,   2,  1, 1, 1, 320, 1, 0, 12),//Frame mode + HEVC tile mode
+    DP_COLOR_420_BLKP_UFO_10_H  = DP_COLORFMT_PACK(1, 0,  5,   2,  1, 1, 1, 320, 1, 0, 12),//Frame mode + Block mode
+    DP_COLOR_420_BLKP_UFO_10_V  = DP_COLORFMT_PACK(1, 1,  5,   2,  1, 1, 1, 320, 1, 0, 12),//Frame mode + HEVC tile mode
+
+    // Loose 10bit format
+    DP_COLOR_UYVY_10L       = DP_COLORFMT_PACK(0, 1,  0,   1,  0, 1, 0, 20,  1, 0, 4),
+    DP_COLOR_VYUY_10L       = DP_COLORFMT_PACK(0, 1,  0,   1,  0, 1, 0, 20,  1, 1, 4),
+    DP_COLOR_YUYV_10L       = DP_COLORFMT_PACK(0, 1,  0,   1,  0, 1, 0, 20,  1, 0, 5),
+    DP_COLOR_YVYU_10L       = DP_COLORFMT_PACK(0, 1,  0,   1,  0, 1, 0, 20,  1, 1, 5),
+    DP_COLOR_NV12_10L       = DP_COLORFMT_PACK(0, 1,  0,   2,  1, 1, 1, 10,  1, 0, 12),
+    DP_COLOR_NV21_10L       = DP_COLORFMT_PACK(0, 1,  0,   2,  1, 1, 1, 10,  1, 1, 12),
+    DP_COLOR_NV16_10L       = DP_COLORFMT_PACK(0, 1,  0,   2,  1, 1, 0, 10,  1, 0, 13),
+    DP_COLOR_NV61_10L       = DP_COLORFMT_PACK(0, 1,  0,   2,  1, 1, 0, 10,  1, 1, 13),
+    DP_COLOR_YV12_10L       = DP_COLORFMT_PACK(0, 1,  0,   3,  0, 1, 1, 10,  1, 1, 8),
+    DP_COLOR_I420_10L       = DP_COLORFMT_PACK(0, 1,  0,   3,  0, 1, 1, 10,  1, 0, 8),
+
+//    DP_COLOR_YUV422I        = DP_COLORFMT_PACK(1,  0, 1, 0, 16, 1, 41),//Dup to DP_COLOR_YUYV
+//    DP_COLOR_Y800           = DP_COLORFMT_PACK(1,  0, 1, 0, 8, 1, 42),//Dup to DP_COLOR_GREY
+//    DP_COLOR_COMPACT_RAW1   = DP_COLORFMT_PACK(1,  0, 1, 0, 10, 2, 43),//Dup to Bayer10
+//    DP_COLOR_420_3P_YVU     = DP_COLORFMT_PACK(3,  0, 1, 1,  8, 1, 44),//Dup to DP_COLOR_YV12
+} DP_COLOR_ENUM;
+
+// Legacy for 6589 compatible
+typedef DP_COLOR_ENUM DpColorFormat;
+
+#define eYUV_420_3P             DP_COLOR_I420
+#define eYUV_420_2P_YUYV        DP_COLOR_YUYV
+#define eYUV_420_2P_UYVY        DP_COLOR_UYVY
+#define eYUV_420_2P_YVYU        DP_COLOR_YVYU
+#define eYUV_420_2P_VYUY        DP_COLOR_VYUY
+#define eYUV_420_2P_ISP_BLK     DP_COLOR_420_BLKP
+#define eYUV_420_2P_VDO_BLK     DP_COLOR_420_BLKI
+#define eYUV_422_3P             DP_COLOR_I422
+#define eYUV_422_2P             DP_COLOR_NV16
+#define eYUV_422_I              DP_COLOR_YUYV
+#define eYUV_422_I_BLK          DP_COLOR_422_BLKP
+#define eYUV_444_3P             DP_COLOR_I444
+#define eYUV_444_2P             DP_COLOR_NV24
+#define eYUV_444_1P             DP_COLOR_YUV444
+#define eBAYER8                 DP_COLOR_BAYER8
+#define eBAYER10                DP_COLOR_BAYER10
+#define eBAYER12                DP_COLOR_BAYER12
+#define eRGB565                 DP_COLOR_RGB565
+#define eBGR565                 DP_COLOR_BGR565
+#define eRGB888                 DP_COLOR_RGB888
+#define eBGR888                 DP_COLOR_BGR888
+#define eARGB8888               DP_COLOR_ARGB8888
+#define eABGR8888               DP_COLOR_ABGR8888
+#define DP_COLOR_XRGB8888       DP_COLOR_ARGB8888
+#define DP_COLOR_XBGR8888       DP_COLOR_ABGR8888
+#define eRGBA8888               DP_COLOR_RGBA8888
+#define eBGRA8888               DP_COLOR_BGRA8888
+#define eXRGB8888               DP_COLOR_XRGB8888
+#define eXBGR8888               DP_COLOR_XBGR8888
+#define DP_COLOR_RGBX8888       DP_COLOR_RGBA8888
+#define DP_COLOR_BGRX8888       DP_COLOR_BGRA8888
+#define eRGBX8888               DP_COLOR_RGBX8888
+#define eBGRX8888               DP_COLOR_BGRX8888
+#define ePARGB8888              DP_COLOR_PARGB8888
+#define eXARGB8888              DP_COLOR_XARGB8888
+#define ePABGR8888              DP_COLOR_PABGR8888
+#define eXABGR8888              DP_COLOR_XABGR8888
+#define eGREY                   DP_COLOR_GREY
+#define eI420                   DP_COLOR_I420
+#define eYV12                   DP_COLOR_YV12
+#define eIYU2                   DP_COLOR_IYU2
+
+
+#define eYV21                   DP_COLOR_I420
+#define eNV12_BLK               DP_COLOR_420_BLKP
+#define eNV12_BLK_FCM           DP_COLOR_420_BLKI
+#define eYUV_420_3P_YVU         DP_COLOR_YV12
+
+#define eNV12_BP                DP_COLOR_420_BLKP
+#define eNV12_BI                DP_COLOR_420_BLKI
+#define eNV12                   DP_COLOR_NV12
+#define eNV21                   DP_COLOR_NV21
+#define eI422                   DP_COLOR_I422
+#define eYV16                   DP_COLOR_YV16
+#define eNV16                   DP_COLOR_NV16
+#define eNV61                   DP_COLOR_NV61
+#define eUYVY                   DP_COLOR_UYVY
+#define eVYUY                   DP_COLOR_VYUY
+#define eYUYV                   DP_COLOR_YUYV
+#define eYVYU                   DP_COLOR_YVYU
+#define eUYVY_BP                DP_COLOR_422_BLKP
+#define eI444                   DP_COLOR_I444
+#define eNV24                   DP_COLOR_NV24
+#define eNV42                   DP_COLOR_NV42
+#define DP_COLOR_YUY2           DP_COLOR_YUYV
+#define eYUY2                   DP_COLOR_YUY2
+#define eY800                   DP_COLOR_GREY
+//#define eIYU2
+#define eMTKYUV                 DP_COLOR_422_BLKP
+
+#define eCompactRaw1            DP_COLOR_BAYER10
+
+
+enum DpInterlaceFormat
+{
+    eInterlace_None,
+    eTop_Field,
+    eBottom_Field
+};
+
+enum DpSecure
+{
+    DP_SECURE_NONE  = 0,
+    DP_SECURE       = 1,
+    DP_SECURE_SHIFT = 8
+};
+
+enum DpBlitUser
+{
+    DP_BLIT_HWC0 = 0,
+    DP_BLIT_HWC1 = 1,
+    DP_BLIT_HWC2 = 2,
+    DP_BLIT_HWC3 = 3,
+    DP_BLIT_HWC4 = 4,
+    DP_BLIT_HWC5 = 5,
+
+    DP_BLIT_GENERAL_USER = DP_BLIT_HWC0,
+    DP_BLIT_GPU = DP_BLIT_HWC1,
+    // GPU_2
+    // RESERVED
+    DP_BLIT_HWC_120FPS = DP_BLIT_HWC4,
+    DP_BLIT_ADDITIONAL_DISPLAY = DP_BLIT_HWC5,
+};
+
+#define MAX_NUM_READBACK_REGS (20)
+
+#define VENC_ENABLE_FLAG    (0x08967)
+
+#endif  // __DP_DATA_TYPE_H__
diff --git a/media/libstagefright/foundation/Android.bp b/media/libstagefright/foundation/Android.bp
index 221af1d07a..ebeb0e16fe 100644
--- a/media/libstagefright/foundation/Android.bp
+++ b/media/libstagefright/foundation/Android.bp
@@ -37,6 +37,7 @@ cc_library_shared {
         "-Wno-multichar",
         "-Werror",
         "-Wall",
+        "-DMTK_HARDWARE",
     ],
 
     shared_libs: [
diff --git a/media/libstagefright/foundation/MediaBufferGroup.cpp b/media/libstagefright/foundation/MediaBufferGroup.cpp
index cb62d92912..d757e376c0 100644
--- a/media/libstagefright/foundation/MediaBufferGroup.cpp
+++ b/media/libstagefright/foundation/MediaBufferGroup.cpp
@@ -32,6 +32,11 @@ constexpr T MIN(const T &a, const T &b) { return a <= b ? a : b; }
 static const size_t kSharedMemoryThreshold = MIN(
         (size_t)MediaBuffer::kSharedMemThreshold, (size_t)(4 * 1024));
 
+#ifdef MTK_HARDWARE
+MediaBufferGroup::MediaBufferGroup() :
+    mGrowthLimit(0) {
+}
+#endif
 MediaBufferGroup::MediaBufferGroup(size_t growthLimit) :
     mGrowthLimit(growthLimit) {
 }
@@ -138,6 +143,11 @@ bool MediaBufferGroup::has_buffers() {
     return false;
 }
 
+#ifdef MTK_HARDWARE
+status_t MediaBufferGroup::acquire_buffer(MediaBuffer **buffer, bool nonBlocking) {
+    return acquire_buffer(buffer, nonBlocking, 0);
+}
+#endif
 status_t MediaBufferGroup::acquire_buffer(
         MediaBuffer **out, bool nonBlocking, size_t requestedSize) {
     Mutex::Autolock autoLock(mLock);
diff --git a/media/libstagefright/include/media/stagefright/ACodec.h b/media/libstagefright/include/media/stagefright/ACodec.h
index 424246dfe1..6a3cefffc5 100644
--- a/media/libstagefright/include/media/stagefright/ACodec.h
+++ b/media/libstagefright/include/media/stagefright/ACodec.h
@@ -323,6 +323,9 @@ private:
     status_t submitOutputMetadataBuffer();
     void signalSubmitOutputMetadataBufferIfEOS_workaround();
     status_t allocateOutputBuffersFromNativeWindow();
+#ifdef MTK_HARDWARE
+    void setHalWindowColorFormat(OMX_COLOR_FORMATTYPE &eHalColorFormat);
+#endif
     status_t cancelBufferToNativeWindow(BufferInfo *info);
     status_t freeOutputBuffersNotOwnedByComponent();
     BufferInfo *dequeueBufferFromNativeWindow();
diff --git a/media/libstagefright/include/media/stagefright/CameraSource.h b/media/libstagefright/include/media/stagefright/CameraSource.h
index d6149c0f77..b0fedf2f45 100644
--- a/media/libstagefright/include/media/stagefright/CameraSource.h
+++ b/media/libstagefright/include/media/stagefright/CameraSource.h
@@ -90,7 +90,7 @@ public:
                                           Size videoSize,
                                           int32_t frameRate,
                                           const sp<IGraphicBufferProducer>& surface,
-                                          bool storeMetaDataInVideoBuffers = true);
+                                          bool storeMetaDataInVideoBuffers = false);
 
     virtual ~CameraSource();
 
diff --git a/media/libstagefright/include/media/stagefright/ColorConverter.h b/media/libstagefright/include/media/stagefright/ColorConverter.h
index 7ac9b3785e..e2b1060910 100644
--- a/media/libstagefright/include/media/stagefright/ColorConverter.h
+++ b/media/libstagefright/include/media/stagefright/ColorConverter.h
@@ -91,6 +91,12 @@ private:
 
     ColorConverter(const ColorConverter &);
     ColorConverter &operator=(const ColorConverter &);
+#ifdef MTK_HARDWARE
+    status_t convertYUVToRGBHW(
+	const BitmapParams &src, const BitmapParams &dst);
+    void dumpColorConverterData(const char * filepath,
+	const void * buffer, size_t size, const char * propty);
+#endif
 };
 
 }  // namespace android
diff --git a/media/libstagefright/include/media/stagefright/MediaBufferGroup.h b/media/libstagefright/include/media/stagefright/MediaBufferGroup.h
index 30514062da..d2a7d890f7 100644
--- a/media/libstagefright/include/media/stagefright/MediaBufferGroup.h
+++ b/media/libstagefright/include/media/stagefright/MediaBufferGroup.h
@@ -29,7 +29,12 @@ class MetaData;
 
 class MediaBufferGroup : public MediaBufferObserver {
 public:
+#ifdef MTK_HARDWARE
+    MediaBufferGroup();
+    MediaBufferGroup(size_t growthLimit);
+#else
     MediaBufferGroup(size_t growthLimit = 0);
+#endif
 
     // create a media buffer group with preallocated buffers
     MediaBufferGroup(size_t buffers, size_t buffer_size, size_t growthLimit = 0);
@@ -48,8 +53,14 @@ public:
     // If requestedSize is 0, any free MediaBuffer will be returned.
     // If requestedSize is > 0, the returned MediaBuffer should have buffer
     // size of at least requstedSize.
+#ifdef MTK_HARDWARE
+    status_t acquire_buffer(MediaBuffer **buffer, bool nonBlocking = false);
+    status_t acquire_buffer(
+            MediaBuffer **buffer, bool nonBlocking, size_t requestedSize);
+#else
     status_t acquire_buffer(
             MediaBuffer **buffer, bool nonBlocking = false, size_t requestedSize = 0);
+#endif
 
     size_t buffers() const { return mBuffers.size(); }
 
diff --git a/media/libstagefright/include/media/stagefright/MediaCodec.h b/media/libstagefright/include/media/stagefright/MediaCodec.h
index 10304077e3..fc648d0177 100644
--- a/media/libstagefright/include/media/stagefright/MediaCodec.h
+++ b/media/libstagefright/include/media/stagefright/MediaCodec.h
@@ -58,12 +58,23 @@ using hardware::cas::native::V1_0::IDescrambler;
 struct MediaCodec : public AHandler {
     enum ConfigureFlags {
         CONFIGURE_FLAG_ENCODE   = 1,
+#ifdef MTK_HARDWARE
+        CONFIGURE_FLAG_ENABLE_THUMBNAIL_OPTIMIZATION = (0x1<<2),
+#endif
     };
 
     enum BufferFlags {
         BUFFER_FLAG_SYNCFRAME   = 1,
         BUFFER_FLAG_CODECCONFIG = 2,
         BUFFER_FLAG_EOS         = 4,
+#ifdef MTK_HARDWARE
+        BUFFER_FLAG_ENDOFFRAME  = 8,
+        BUFFER_FLAG_DUMMY       = 16,
+        BUFFER_FLAG_INTERPOLATE_FRAME  = 32,
+        BUFFER_FLAG_INVALID_PTS = 64,
+        BUFFER_FLAG_PARTAIL_FRAME  = 128,
+        BUFFER_FLAG_MULTISLICE = 256,
+#endif
     };
 
     enum {
diff --git a/media/libstagefright/omx/Android.bp b/media/libstagefright/omx/Android.bp
index 54c2d4fe6f..6ac00af667 100644
--- a/media/libstagefright/omx/Android.bp
+++ b/media/libstagefright/omx/Android.bp
@@ -77,6 +77,9 @@ cc_library_shared {
         "-Wall",
         "-Wno-unused-parameter",
         "-Wno-documentation",
+        "-DMTK_HARDWARE",
+        "-DUSE_LEGACY_MTK_AV_BLOB",
+        "-DHAS_LEGACY_CAMERA_HAL1",
     ],
 
     product_variables: {
@@ -125,6 +128,21 @@ cc_library_shared {
     export_shared_lib_headers: [
         "libmedia_omx",
     ],
+
+    cflags: [
+        "-DMTK_HARDWARE",
+        "-DUSE_LEGACY_MTK_AV_BLOB",
+        "-DHAS_LEGACY_CAMERA_HAL1",
+    ],
+
+    product_variables: {
+        bootleggers: {
+            needs_legacy_camera_hal1_dyn_native_handle: {
+                cppflags: ["-DNEEDS_LEGACY_CAMERA_HAL1_DYN_NATIVE_HANDLE"],
+            },
+        },
+    },
+
     sanitize: {
         misc_undefined: [
             "signed-integer-overflow",
diff --git a/media/libstagefright/omx/OMXNodeInstance.cpp b/media/libstagefright/omx/OMXNodeInstance.cpp
index 04866d5baf..280f6ac536 100644
--- a/media/libstagefright/omx/OMXNodeInstance.cpp
+++ b/media/libstagefright/omx/OMXNodeInstance.cpp
@@ -352,7 +352,9 @@ OMXNodeInstance::OMXNodeInstance(
       mSailed(false),
       mQueriedProhibitedExtensions(false),
       mQuirks(0),
+#ifndef USE_LEGACY_MTK_AV_BLOB
       mBufferIDCount(0),
+#endif
       mRestorePtsFailed(false),
       mMaxTimestampGapUs(-1ll),
       mPrevOriginalTimeUs(-1ll),
@@ -1720,10 +1722,30 @@ status_t OMXNodeInstance::emptyBuffer_l(
     BufferMeta *buffer_meta =
         static_cast<BufferMeta *>(header->pAppPrivate);
 
+#ifndef HAS_LEGACY_CAMERA_HAL1
     // set up proper filled length if component is configured for gralloc metadata mode
     // ignore rangeOffset in this case (as client may be assuming ANW meta buffers).
     if (mMetadataType[kPortIndexInput] == kMetadataBufferTypeGrallocSource) {
         header->nFilledLen = rangeLength ? sizeof(VideoGrallocMetadata) : 0;
+#else
+    sp<ABuffer> backup = buffer_meta->getBuffer(header, false /* limit */);
+    sp<ABuffer> codec = buffer_meta->getBuffer(header, false /* limit */);
+
+    // convert incoming ANW meta buffers if component is configured for gralloc metadata mode
+    // ignore rangeOffset in this case
+    if (mMetadataType[kPortIndexInput] == kMetadataBufferTypeGrallocSource
+            && backup->capacity() >= sizeof(VideoNativeMetadata)
+            && codec->capacity() >= sizeof(VideoGrallocMetadata)
+            && ((VideoNativeMetadata *)backup->base())->eType
+                    == kMetadataBufferTypeANWBuffer) {
+        VideoNativeMetadata &backupMeta = *(VideoNativeMetadata *)backup->base();
+        VideoGrallocMetadata &codecMeta = *(VideoGrallocMetadata *)codec->base();
+        CLOG_BUFFER(emptyBuffer, "converting ANWB %p to handle %p",
+                backupMeta.pBuffer, backupMeta.pBuffer->handle);
+        codecMeta.pHandle = backupMeta.pBuffer != NULL ? backupMeta.pBuffer->handle : NULL;
+        codecMeta.eType = kMetadataBufferTypeGrallocSource;
+        header->nFilledLen = rangeLength ? sizeof(codecMeta) : 0;
+#endif
         header->nOffset = 0;
     } else {
         // rangeLength and rangeOffset must be a subset of the allocated data in the buffer.
@@ -2359,6 +2381,7 @@ void OMXNodeInstance::freeActiveBuffers() {
     }
 }
 
+#ifndef USE_LEGACY_MTK_AV_BLOB
 IOMX::buffer_id OMXNodeInstance::makeBufferID(OMX_BUFFERHEADERTYPE *bufferHeader) {
     if (bufferHeader == NULL) {
         return 0;
@@ -2424,5 +2447,27 @@ void OMXNodeInstance::invalidateBufferID(IOMX::buffer_id buffer) {
     mBufferHeaderToBufferID.removeItem(mBufferIDToBufferHeader.valueAt(index));
     mBufferIDToBufferHeader.removeItemsAt(index);
 }
+#else
+IOMX::buffer_id OMXNodeInstance::makeBufferID(OMX_BUFFERHEADERTYPE *bufferHeader) {
+    return (IOMX::buffer_id)(size_t)bufferHeader;
+}
+
+OMX_BUFFERHEADERTYPE *OMXNodeInstance::findBufferHeader(
+        IOMX::buffer_id buffer, OMX_U32 portIndex __unused) {
+    return findBufferHeader(buffer);
+}
+
+
+OMX_BUFFERHEADERTYPE *OMXNodeInstance::findBufferHeader(IOMX::buffer_id buffer) {
+    return (OMX_BUFFERHEADERTYPE *)(size_t)buffer;
+}
+
+IOMX::buffer_id OMXNodeInstance::findBufferID(OMX_BUFFERHEADERTYPE *bufferHeader) {
+    return (IOMX::buffer_id)(size_t)bufferHeader;
+}
+
+void OMXNodeInstance::invalidateBufferID(IOMX::buffer_id buffer __unused) {
+}
+#endif
 
 }  // namespace android
diff --git a/media/libstagefright/omx/OMXUtils.cpp b/media/libstagefright/omx/OMXUtils.cpp
index 5894837107..720cb2ea1d 100644
--- a/media/libstagefright/omx/OMXUtils.cpp
+++ b/media/libstagefright/omx/OMXUtils.cpp
@@ -213,7 +213,8 @@ bool DescribeDefaultColorFormat(DescribeColorFormat2Params &params) {
         fmt != OMX_COLOR_FormatYUV420PackedPlanar &&
         fmt != OMX_COLOR_FormatYUV420SemiPlanar &&
         fmt != OMX_COLOR_FormatYUV420PackedSemiPlanar &&
-        fmt != (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12) {
+        fmt != (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12 &&
+        fmt != OMX_MTK_COLOR_FormatYV12) {
         ALOGW("do not know color format 0x%x = %d", fmt, fmt);
         return false;
     }
@@ -247,6 +248,7 @@ bool DescribeDefaultColorFormat(DescribeColorFormat2Params &params) {
     image.mPlane[image.Y].mVertSubsampling = 1;
 
     switch ((int)fmt) {
+		case OMX_MTK_COLOR_FormatYV12:
         case HAL_PIXEL_FORMAT_YV12:
             if (params.bUsingNativeBuffers) {
                 size_t ystride = align(params.nStride, 16);
diff --git a/media/libstagefright/omx/include/media/stagefright/omx/OMXNodeInstance.h b/media/libstagefright/omx/include/media/stagefright/omx/OMXNodeInstance.h
index 1065ca58e2..6e60b1b084 100644
--- a/media/libstagefright/omx/include/media/stagefright/omx/OMXNodeInstance.h
+++ b/media/libstagefright/omx/include/media/stagefright/omx/OMXNodeInstance.h
@@ -145,10 +145,12 @@ private:
     };
     Vector<ActiveBuffer> mActiveBuffers;
     // for buffer ptr to buffer id translation
+#ifndef USE_LEGACY_MTK_AV_BLOB
     Mutex mBufferIDLock;
     uint32_t mBufferIDCount;
     KeyedVector<IOMX::buffer_id, OMX_BUFFERHEADERTYPE *> mBufferIDToBufferHeader;
     KeyedVector<OMX_BUFFERHEADERTYPE *, IOMX::buffer_id> mBufferHeaderToBufferID;
+#endif
 
     bool mLegacyAdaptiveExperiment;
     IOMX::PortMode mPortMode[2];
@@ -191,6 +193,9 @@ private:
     // For buffer id management
     IOMX::buffer_id makeBufferID(OMX_BUFFERHEADERTYPE *bufferHeader);
     OMX_BUFFERHEADERTYPE *findBufferHeader(IOMX::buffer_id buffer, OMX_U32 portIndex);
+#ifdef USE_LEGACY_MTK_AV_BLOB
+    OMX_BUFFERHEADERTYPE *findBufferHeader(IOMX::buffer_id buffer);
+#endif
     IOMX::buffer_id findBufferID(OMX_BUFFERHEADERTYPE *bufferHeader);
     void invalidateBufferID(IOMX::buffer_id buffer);
 
diff --git a/services/audioflinger/Android.mk b/services/audioflinger/Android.mk
index d0454d4afa..578dc9a5b1 100644
--- a/services/audioflinger/Android.mk
+++ b/services/audioflinger/Android.mk
@@ -76,6 +76,10 @@ LOCAL_SRC_FILES += \
     FastThreadDumpState.cpp  \
     FastThreadState.cpp
 
+ifeq ($(BOARD_USES_LEGACY_MTK_AV_BLOB), true)
+LOCAL_CFLAGS += -DLEGACY_MTK_AV_BLOB
+endif
+
 LOCAL_CFLAGS += -DSTATE_QUEUE_INSTANTIATIONS='"StateQueueInstantiations.cpp"'
 
 LOCAL_CFLAGS += -fvisibility=hidden
diff --git a/services/audioflinger/Threads.cpp b/services/audioflinger/Threads.cpp
index e202ca4d4b..8d12d5fbd0 100644
--- a/services/audioflinger/Threads.cpp
+++ b/services/audioflinger/Threads.cpp
@@ -6381,6 +6381,7 @@ reacquire_wakelock:
         mTimestamp.mTimeNs[ExtendedTimestamp::LOCATION_SERVER] = systemTime();
 
         // Update server timestamp with kernel stats
+#ifndef LEGACY_MTK_AV_BLOB
         if (mPipeSource.get() == nullptr /* don't obtain for FastCapture, could block */) {
             int64_t position, time;
             int ret = mInput->stream->getCapturePosition(&position, &time);
@@ -6394,6 +6395,7 @@ reacquire_wakelock:
                 // as the read obtains a lock, preventing the timestamp call from executing.
             }
         }
+#endif
         // Use this to track timestamp information
         // ALOGD("%s", mTimestamp.toString().c_str());
 
diff --git a/services/camera/libcameraservice/Android.mk b/services/camera/libcameraservice/Android.mk
index 762959430e..e8faf0ae51 100644
--- a/services/camera/libcameraservice/Android.mk
+++ b/services/camera/libcameraservice/Android.mk
@@ -39,6 +39,7 @@ LOCAL_SRC_FILES :=  \
     api1/client2/JpegCompressor.cpp \
     api1/client2/CaptureSequencer.cpp \
     api1/client2/ZslProcessor.cpp \
+    api1/StreamImgBuf.cpp \
     api2/CameraDeviceClient.cpp \
     device1/CameraHardwareInterface.cpp \
     device3/Camera3Device.cpp \
@@ -74,6 +75,9 @@ LOCAL_SHARED_LIBRARIES:= \
     libhidltransport \
     libjpeg \
     libmemunreachable \
+    libcam.client \
+    libcam_utils \
+    libmtkcamera_client \
     android.hardware.camera.common@1.0 \
     android.hardware.camera.provider@2.4 \
     android.hardware.camera.device@1.0 \
@@ -90,12 +94,16 @@ LOCAL_EXPORT_SHARED_LIBRARY_HEADERS := libbinder libcamera_client libfmq
 
 LOCAL_C_INCLUDES += \
     system/media/private/camera/include \
-    frameworks/native/include/media/openmax
+    system/media/camera/include \
+    frameworks/native/include/media/openmax \
+    frameworks/native/libs/nativewindow/include \
+    frameworks/native/libs/nativebase/include \
+    frameworks/native/libs/arect/include
 
 LOCAL_EXPORT_C_INCLUDE_DIRS := \
     frameworks/av/services/camera/libcameraservice
 
-LOCAL_CFLAGS += -Wall -Wextra -Werror
+LOCAL_CFLAGS += -Wall -Wextra -Wno-narrowing -DMTK_HARDWARE
 
 # Workaround for invalid unused-lambda-capture warning http://b/38349491
 LOCAL_CLANG_CFLAGS += -Wno-error=unused-lambda-capture
diff --git a/services/camera/libcameraservice/api1/CamUtils.h b/services/camera/libcameraservice/api1/CamUtils.h
new file mode 100644
index 0000000000..22a5f9fb25
--- /dev/null
+++ b/services/camera/libcameraservice/api1/CamUtils.h
@@ -0,0 +1,64 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+#ifndef _MTK_CLIENT_DISPLAYCLIENT_INC_CAMUTILS_H_
+#define _MTK_CLIENT_DISPLAYCLIENT_INC_CAMUTILS_H_
+
+
+/******************************************************************************
+*
+*******************************************************************************/
+//
+#include <stdlib.h>
+//
+#include <hardware/camera.h>
+#include <system/camera.h>
+//
+#include <cutils/log.h>
+#include <common.h>
+#include <utils/common.h>
+
+#include <v1/camutils/CamInfo.h>
+#include <v1/camutils/IBuffer.h>
+#include <v1/camutils/ICameraBuffer.h>
+#include <v1/camutils/IImgBufQueue.h>
+#include <v1/camutils/ImgBufQueue.h>
+
+using namespace android::MtkCamUtils;
+
+
+#endif  //_MTK_CLIENT_DISPLAYCLIENT_INC_CAMUTILS_H_
diff --git a/services/camera/libcameraservice/api1/CameraClient.cpp b/services/camera/libcameraservice/api1/CameraClient.cpp
index 48757acdfc..59094a840e 100644
--- a/services/camera/libcameraservice/api1/CameraClient.cpp
+++ b/services/camera/libcameraservice/api1/CameraClient.cpp
@@ -26,6 +26,11 @@
 #include "device1/CameraHardwareInterface.h"
 #include "CameraService.h"
 
+#ifdef MTK_HARDWARE
+    #include <camera/MtkCamera.h>
+    #include <camera/MtkCameraParameters.h>
+#endif
+
 namespace android {
 
 #define LOG1(...) ALOGD_IF(gLogLevel >= 1, __VA_ARGS__);
@@ -96,9 +101,14 @@ status_t CameraClient::initialize(sp<CameraProviderManager> manager) {
             (void *)(uintptr_t)mCameraId);
 
     // Enable zoom, error, focus, and metadata messages by default
+#ifdef MTK_HARDWARE
+    enableMsgType(CAMERA_MSG_ERROR | CAMERA_MSG_ZOOM | CAMERA_MSG_FOCUS |
+                  CAMERA_MSG_PREVIEW_METADATA | CAMERA_MSG_FOCUS_MOVE |
+                  MTK_CAMERA_MSG_EXT_NOTIFY | MTK_CAMERA_MSG_EXT_DATA);
+#else
     enableMsgType(CAMERA_MSG_ERROR | CAMERA_MSG_ZOOM | CAMERA_MSG_FOCUS |
                   CAMERA_MSG_PREVIEW_METADATA | CAMERA_MSG_FOCUS_MOVE);
-
+#endif
     LOG1("CameraClient::initialize X (pid %d, id %d)", callingPid, mCameraId);
     return OK;
 }
@@ -311,6 +321,12 @@ status_t CameraClient::setPreviewWindow(const sp<IBinder>& binder,
         }
     }
 
+#ifdef MTK_HARDWARE
+    else if ( window == nullptr || window == 0 ) {
+        result = mHardware->setPreviewWindow(nullptr);
+    }
+#endif
+
     if (result == NO_ERROR) {
         // Everything has succeeded.  Disconnect the old window and remember the
         // new window.
@@ -368,14 +384,18 @@ status_t CameraClient::setPreviewCallbackTarget(
 
 // start preview mode
 status_t CameraClient::startPreview() {
+#ifndef MTK_HARDWARE
     Mutex::Autolock lock(mLock);
+#endif
     LOG1("startPreview (pid %d)", getCallingPid());
     return startCameraMode(CAMERA_PREVIEW_MODE);
 }
 
 // start recording mode
 status_t CameraClient::startRecording() {
+#ifndef MTK_HARDWARE
     Mutex::Autolock lock(mLock);
+#endif
     LOG1("startRecording (pid %d)", getCallingPid());
     return startCameraMode(CAMERA_RECORDING_MODE);
 }
@@ -383,6 +403,9 @@ status_t CameraClient::startRecording() {
 // start preview or recording
 status_t CameraClient::startCameraMode(camera_mode mode) {
     LOG1("startCameraMode(%d)", mode);
+#ifdef MTK_HARDWARE
+    Mutex::Autolock lock(mLock);
+#endif
     status_t result = checkPidAndHardware();
     if (result != NO_ERROR) return result;
 
@@ -801,6 +824,9 @@ void CameraClient::disableMsgType(int32_t msgType) {
 
 #define CHECK_MESSAGE_INTERVAL 10 // 10ms
 bool CameraClient::lockIfMessageWanted(int32_t msgType) {
+#ifdef MTK_HARDWARE
+    return true;
+#else
     int sleepCount = 0;
     while (mMsgEnabled & msgType) {
         if (mLock.tryLock() == NO_ERROR) {
@@ -824,6 +850,7 @@ bool CameraClient::lockIfMessageWanted(int32_t msgType) {
     }
     ALOGW("lockIfMessageWanted(%d): dropped unwanted message", msgType);
     return false;
+#endif
 }
 
 sp<CameraClient> CameraClient::getClientFromCookie(void* user) {
@@ -861,6 +888,11 @@ void CameraClient::notifyCallback(int32_t msgType, int32_t ext1,
     if (!client->lockIfMessageWanted(msgType)) return;
 
     switch (msgType) {
+#ifdef MTK_HARDWARE
+        case MTK_CAMERA_MSG_EXT_NOTIFY:
+            client->handleMtkExtNotify(ext1, ext2);
+            break;
+#endif
         case CAMERA_MSG_SHUTTER:
             // ext1 is the dimension of the yuv picture.
             client->handleShutter();
@@ -885,6 +917,11 @@ void CameraClient::dataCallback(int32_t msgType,
         return;
     }
 
+    if ((msgType & MTK_CAMERA_MSG_EXT_DATA)) {
+        client->handleMtkExtData(dataPtr, metadata);
+        return;
+    }
+
     switch (msgType & ~CAMERA_MSG_PREVIEW_METADATA) {
         case CAMERA_MSG_PREVIEW_FRAME:
             client->handlePreviewData(msgType, dataPtr, metadata);
@@ -1205,4 +1242,335 @@ status_t CameraClient::setVideoTarget(const sp<IGraphicBufferProducer>& bufferPr
     return INVALID_OPERATION;
 }
 
+#ifdef MTK_HARDWARE
+/******************************************************************************
+ *
+ ******************************************************************************/
+void CameraClient::playRecordingSound()
+{
+    CameraParameters params(mHardware->getParameters());
+    int value = 0;
+    value = params.getInt("rec-mute-ogg");
+    if (value != 1) {
+        sCameraService->playSound(CameraService::SOUND_RECORDING_START);
+    }
+}
+
+
+/******************************************************************************
+ *
+ ******************************************************************************/
+void CameraClient::handleMtkExtNotify(int32_t ext1, int32_t ext2)
+{
+    int32_t const extMsgType = ext1;
+    switch  (extMsgType)
+    {
+    case MTK_CAMERA_MSG_EXT_NOTIFY_CAPTURE_DONE:
+        handleMtkExtCaptureDone(ext1, ext2);
+        break;
+    //
+    case MTK_CAMERA_MSG_EXT_NOTIFY_SHUTTER:
+        handleMtkExtShutter(ext1, ext2);
+        break;
+    //
+    case MTK_CAMERA_MSG_EXT_NOTIFY_BURST_SHUTTER:
+        handleMtkExtBurstShutter(ext1, ext2);
+        break;
+    case MTK_CAMERA_MSG_EXT_NOTIFY_CONTINUOUS_SHUTTER:
+        handleMtkExtContinuousShutter(ext1, ext2);
+        break;
+    case MTK_CAMERA_MSG_EXT_NOTIFY_CONTINUOUS_END:
+        handleMtkExtContinuousEnd(ext1, ext2);
+        break;
+    //
+    default:
+        handleGenericNotify(MTK_CAMERA_MSG_EXT_NOTIFY, ext1, ext2);
+        break;
+    }
+}
+
+
+/******************************************************************************
+ *
+ ******************************************************************************/
+void CameraClient::handleMtkExtData(const sp<IMemory>& dataPtr, camera_frame_metadata_t *metadata)
+{
+    MtkCamMsgExtDataHelper MtkExtDataHelper;
+
+    if  ( ! MtkExtDataHelper.init(dataPtr) ) {
+        ALOGE("[handleMtkExtData] MtkCamMsgExtDataHelper::init fail - dataPtr(%p), this(%p)", dataPtr.get(), this);
+        return;
+    }
+
+//    void*   const pvExtParam   = MtkExtDataHelper.getExtParamBase();
+//    size_t  const ExtParamSize = MtkExtDataHelper.getExtParamSize();
+    switch  (MtkExtDataHelper.getExtMsgType())
+    {
+    case MTK_CAMERA_MSG_EXT_DATA_COMPRESSED_IMAGE:
+        handleMtkExtDataCompressedImage(dataPtr, metadata);
+        break;
+    //
+    case MTK_CAMERA_MSG_EXT_DATA_BURST_SHOT:
+        handleMtkExtDataBurstShot(dataPtr, metadata);
+        break;
+    //
+    case MTK_CAMERA_MSG_EXT_DATA_CONTINUOUS_SHOT:
+        handleMtkExtDataContinuousShot(dataPtr, metadata);
+        break;
+    //
+    default:
+        handleGenericData(MTK_CAMERA_MSG_EXT_DATA, dataPtr, metadata);
+        break;
+    }
+    MtkExtDataHelper.uninit();
+}
+
+
+/******************************************************************************
+ *  Shutter Callback (not disable CAMERA_MSG_SHUTTER)
+ *      ext2: 1: CameraService will play shutter sound.
+ ******************************************************************************/
+void CameraClient::handleMtkExtShutter(int32_t /*ext1*/, int32_t ext2)
+{
+    ALOGD("[%s] (ext2, mPlayShutterSound)=(%d, %d) \r\n", __FUNCTION__, ext2, mPlayShutterSound);
+
+    if  ( 1 == ext2 ) {
+        if (mPlayShutterSound) {
+            sCameraService->playSound(CameraService::SOUND_SHUTTER);
+        }
+    }
+
+    sp<hardware::ICameraClient> c = mRemoteCallback;
+    if (c != 0) {
+//!++
+#if 1
+#else
+        mLock.unlock();
+#endif
+//!--
+        c->notifyCallback(CAMERA_MSG_SHUTTER, 0, 0);
+        if (!lockIfMessageWanted(CAMERA_MSG_SHUTTER)) return;
+    }
+//    disableMsgType(CAMERA_MSG_SHUTTER);
+
+//!++
+#if 1
+#else
+    mLock.unlock();
+#endif
+//!--
+}
+
+
+/******************************************************************************
+ *  Burst Shutter Callback Handler
+ *       ext2: count-down shutter number; 0: the last one shutter.
+ ******************************************************************************/
+void CameraClient::handleMtkExtBurstShutter(int32_t /*ext1*/, int32_t ext2)
+{
+    handleShutter();
+    if  (0 < ext2) {
+        //  not the last one burst shutter.
+        enableMsgType(CAMERA_MSG_SHUTTER);
+        ALOGD("[handleMtkExtBurstShutter] count-down burst shutter number:%d - enableMsgType(CAMERA_MSG_SHUTTER) \r\n", ext2);
+    }
+    else {
+        ALOGD("[handleMtkExtBurstShutter] the last one burst shutter \r\n");
+    }
+}
+
+
+/******************************************************************************
+ *  Burst Shot (EV Shot)
+ *      int[0]: the total shut count.
+ *      int[1]: count-down shut number; 0: the last one shut.
+ ******************************************************************************/
+void CameraClient::handleMtkExtDataBurstShot(const sp<IMemory>& dataPtr, camera_frame_metadata_t */*metadata*/)
+{
+    MtkCamMsgExtDataHelper MtkExtDataHelper;
+    if  ( ! MtkExtDataHelper.init(dataPtr) ) {
+        ALOGE("[%s] MtkCamMsgExtDataHelper::init fail - dataPtr(%p), this(%p) \r\n", __FUNCTION__, dataPtr.get(), this);
+        return;
+    }
+    //
+    uint_t const*const pExtParam = (uint_t const*)MtkExtDataHelper.getExtParamBase();
+    uint_t const uTotalShutCount = pExtParam[0];
+    uint_t const uCountdownIndex = pExtParam[1];
+    //
+    size_t const    imageSize   = MtkExtDataHelper.getExtParamSize()    - sizeof(uint_t) * 2;
+    ssize_t const   imageOffset = MtkExtDataHelper.getExtParamOffset()  + sizeof(uint_t) * 2;
+    sp<MemoryBase> image = new MemoryBase(MtkExtDataHelper.getHeap(), imageOffset, imageSize);
+    //
+    MtkExtDataHelper.uninit();
+    //
+    //
+    if  (0 < uCountdownIndex) {
+        //  not the last one burst shut.
+        ALOGD("[%s] count-down burst shut number:%d/%d - (size, offset)=(%zu, %zd) \r\n", __FUNCTION__, uCountdownIndex, uTotalShutCount, imageSize, imageOffset);
+    }
+    else {
+        disableMsgType(CAMERA_MSG_COMPRESSED_IMAGE);
+        ALOGD("[%s] the last one burst shut - (size, offset)=(%zu, %zd) \r\n", __FUNCTION__, imageSize, imageOffset);
+    }
+    //
+    if (image == 0) {
+        ALOGE("[%s] fail to new MemoryBase \r\n", __FUNCTION__);
+        return;
+    }
+    //
+    sp<hardware::ICameraClient> c = mRemoteCallback;
+//!++
+#if 1
+#else
+    mLock.unlock();
+#endif
+//!--
+    if (c != 0) {
+        c->dataCallback(CAMERA_MSG_COMPRESSED_IMAGE, image, NULL);
+    }
+}
+
+
+/******************************************************************************
+*   Continuous Shutter Callback Handler
+*       ext2: current continuous shutter number.
+*******************************************************************************/
+void CameraClient::handleMtkExtContinuousShutter(int32_t /*ext1*/, int32_t ext2)
+{
+    //if (mPlayShutterSound) {
+    //    sCameraService->playSound(CameraService::SOUND_SHUTTER);
+    //}
+
+    sp<hardware::ICameraClient> c = mRemoteCallback;
+    if (c != 0) {
+//!++
+#if 1
+#else
+        mLock.unlock();
+#endif
+//!--
+        c->notifyCallback(CAMERA_MSG_SHUTTER, 0, 0);
+        if (!lockIfMessageWanted(CAMERA_MSG_SHUTTER)) return;
+    }
+    //disableMsgType(CAMERA_MSG_SHUTTER);
+
+//!++
+#if 1
+#else
+    mLock.unlock();
+#endif
+//!--
+
+    //enableMsgType(CAMERA_MSG_SHUTTER);
+    ALOGD("[handleMtkExtContinuousShutter] current continuous shutter number:%d \n", ext2);
+}
+
+
+/******************************************************************************
+ *  Continuous Shot
+ *      int[0]: current continuous shut number.
+ ******************************************************************************/
+void CameraClient::handleMtkExtDataContinuousShot(const sp<IMemory>& dataPtr, camera_frame_metadata_t */*metadata*/)
+{
+    MtkCamMsgExtDataHelper MtkExtDataHelper;
+    if  ( ! MtkExtDataHelper.init(dataPtr) ) {
+        ALOGE("[%s] MtkCamMsgExtDataHelper::init fail - dataPtr(%p), this(%p) \r\n", __FUNCTION__, dataPtr.get(), this);
+        return;
+    }
+    //
+    uint_t const*const pExtParam = (uint_t const*)MtkExtDataHelper.getExtParamBase();
+    uint_t const uCurShutCount = pExtParam[0];
+    //
+    size_t const    imageSize   = MtkExtDataHelper.getExtParamSize()    - sizeof(uint_t) * 1;
+    ssize_t const   imageOffset = MtkExtDataHelper.getExtParamOffset()  + sizeof(uint_t) * 1;
+    sp<MemoryBase> image = new MemoryBase(MtkExtDataHelper.getHeap(), imageOffset, imageSize);
+    //
+    MtkExtDataHelper.uninit();
+
+    ALOGD("[%s] current continuous shut number:%d - (size, offset)=(%zu, %zd) \r\n", __FUNCTION__,  uCurShutCount, imageSize, imageOffset);
+
+    //
+    if (image == 0) {
+        ALOGE("[%s] fail to new MemoryBase \r\n", __FUNCTION__);
+        return;
+    }
+    //
+    sp<hardware::ICameraClient> c = mRemoteCallback;
+//!++
+#if 1
+#else
+    mLock.unlock();
+#endif
+//!--
+    if (c != 0) {
+        c->dataCallback(CAMERA_MSG_COMPRESSED_IMAGE, image, NULL);
+    }
+}
+
+
+/******************************************************************************
+ *  Continuous EndCallback Handler
+ ******************************************************************************/
+void CameraClient::handleMtkExtContinuousEnd(int32_t ext1, int32_t ext2)
+{
+    disableMsgType(CAMERA_MSG_SHUTTER);
+    disableMsgType(CAMERA_MSG_COMPRESSED_IMAGE);
+    handleGenericNotify(MTK_CAMERA_MSG_EXT_NOTIFY, ext1, ext2);
+    ALOGD("[handleMtkExtContinuousEnd] total continuous shut number is %d \n", ext2);
+}
+
+
+/******************************************************************************
+ *  Capture done (disable CAMERA_MSG_SHUTTER / CAMERA_MSG_COMPRESSED_IMAGE)
+ ******************************************************************************/
+void CameraClient::handleMtkExtCaptureDone(int32_t /*ext1*/, int32_t /*ext2*/)
+{
+    ALOGD("[%s] disable CAMERA_MSG_SHUTTER / CAMERA_MSG_COMPRESSED_IMAGE \r\n", __FUNCTION__);
+    disableMsgType(CAMERA_MSG_SHUTTER);
+    disableMsgType(CAMERA_MSG_COMPRESSED_IMAGE);
+}
+
+
+/******************************************************************************
+ *  Compressed Image (not disable CAMERA_MSG_COMPRESSED_IMAGE)
+ *      int[0]: current shut index; 0: the first one shut.
+ ******************************************************************************/
+void CameraClient::handleMtkExtDataCompressedImage(const sp<IMemory>& dataPtr, camera_frame_metadata_t */*metadata*/)
+{
+    MtkCamMsgExtDataHelper MtkExtDataHelper;
+    if  ( ! MtkExtDataHelper.init(dataPtr) ) {
+        ALOGE("[%s] MtkCamMsgExtDataHelper::init fail - dataPtr(%p), this(%p) \r\n", __FUNCTION__, dataPtr.get(), this);
+        return;
+    }
+    //
+    uint_t const*const pExtParam = (uint_t const*)MtkExtDataHelper.getExtParamBase();
+    uint_t const      uShutIndex = pExtParam[0];
+    //
+    size_t const    imageSize   = MtkExtDataHelper.getExtParamSize()    - sizeof(uint_t) * 1;
+    ssize_t const   imageOffset = MtkExtDataHelper.getExtParamOffset()  + sizeof(uint_t) * 1;
+    sp<MemoryBase> image = new MemoryBase(MtkExtDataHelper.getHeap(), imageOffset, imageSize);
+    //
+    MtkExtDataHelper.uninit();
+
+    ALOGD("[%s] current shut index:%d - (size, offset)=(%zu, %zd) \r\n", __FUNCTION__, uShutIndex, imageSize, imageOffset);
+    //
+    if (image == 0) {
+        ALOGE("[%s] fail to new MemoryBase \r\n", __FUNCTION__);
+        return;
+    }
+    //
+    sp<hardware::ICameraClient> c = mRemoteCallback;
+//!++
+#if 1
+#else
+    mLock.unlock();
+#endif
+//!--
+
+    if (c != 0) {
+        c->dataCallback(CAMERA_MSG_COMPRESSED_IMAGE, image, NULL);
+    }
+}
+#endif
+
 }; // namespace android
diff --git a/services/camera/libcameraservice/api1/CameraClient.h b/services/camera/libcameraservice/api1/CameraClient.h
index a0d9d0add4..84c2a4ddca 100644
--- a/services/camera/libcameraservice/api1/CameraClient.h
+++ b/services/camera/libcameraservice/api1/CameraClient.h
@@ -110,6 +110,11 @@ private:
     static void             handleCallbackTimestampBatch(
                                     int32_t msgType, const std::vector<HandleTimestampMessage>&, void* user);
     // handlers for messages
+#ifdef MTK_HARDWARE
+    void                    handleMtkShutter(int32_t ext2);
+    void                    handleMtkGenericData(int32_t msgType, const sp<IMemory>& dataPtr,
+            camera_frame_metadata_t *metadata);
+#endif
     void                    handleShutter(void);
     void                    handlePreviewData(int32_t msgType, const sp<IMemory>& mem,
             camera_frame_metadata_t *metadata);
@@ -179,6 +184,26 @@ private:
     // is found to be disabled. It returns true if mLock is grabbed.
     bool                    lockIfMessageWanted(int32_t msgType);
 
+#ifdef MTK_HARDWARE
+    //
+    void                handleMtkExtNotify(int32_t ext1, int32_t ext2);
+    void                handleMtkExtData(const sp<IMemory>& dataPtr, camera_frame_metadata_t *metadata);
+    //
+    void                handleMtkExtBurstShutter(int32_t ext1, int32_t ext2);
+    void                handleMtkExtDataBurstShot(const sp<IMemory>& dataPtr, camera_frame_metadata_t *metadata);
+    //
+    void                handleMtkExtContinuousShutter(int32_t ext1, int32_t ext2);
+    void                handleMtkExtDataContinuousShot(const sp<IMemory>& dataPtr, camera_frame_metadata_t *metadata);
+    void                handleMtkExtContinuousEnd(int32_t ext1, int32_t ext2);
+    //
+    void                handleMtkExtCaptureDone(int32_t ext1, int32_t ext2);
+    void                handleMtkExtShutter(int32_t ext1, int32_t ext2);
+    void                handleMtkExtDataCompressedImage(const sp<IMemory>& dataPtr, camera_frame_metadata_t *metadata);
+    //
+    void                playRecordingSound();
+    //
+#endif
+
     bool                 mLongshotEnabled;
     int                  mBurstCnt;
 };
diff --git a/services/camera/libcameraservice/api1/Format.h b/services/camera/libcameraservice/api1/Format.h
new file mode 100644
index 0000000000..f897dc7dec
--- /dev/null
+++ b/services/camera/libcameraservice/api1/Format.h
@@ -0,0 +1,190 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+#ifndef _MTK_HARDWARE_INCLUDE_MTKCAM_UTILS_FORMAT_H_
+#define _MTK_HARDWARE_INCLUDE_MTKCAM_UTILS_FORMAT_H_
+//
+
+
+/******************************************************************************
+ *
+ ******************************************************************************/
+namespace NSCam {
+namespace Utils {
+namespace Format {
+
+bool
+checkValidFormat(
+    int const imageFormat
+);
+
+/*****************************************************************************
+ * @brief Query the plane count.
+ *
+ * @details Given a format of type EImageFormat, return its corresponding
+ * plane count.
+ *
+ * @note
+ *
+ * @param[in] imageFormat: A format of type EImageFormat.
+ *
+ * @return its corresponding plane count.
+ *
+ ******************************************************************************/
+size_t
+queryPlaneCount(
+    int const imageFormat
+);
+
+
+/*****************************************************************************
+ * @brief Query the width in pixels of a specific plane.
+ *
+ * @details Given a format of type EImageFormat, a plane index, and the width in
+ * in pixels of the 0-th plane, return the width in pixels of the given plane.
+ *
+ * @note
+ *
+ * @param[in] imageFormat: A format of type EImageFormat.
+ * @param[in] planeIndex: a specific plane index.
+ * @param[in] widthInPixels: the width in pixels of the 0-th plane.
+ *
+ * @return the width in pixels of the given plane.
+ *
+ ******************************************************************************/
+size_t
+queryPlaneWidthInPixels(
+    int const imageFormat,
+    size_t planeIndex,
+    size_t widthInPixels
+);
+
+
+/*****************************************************************************
+ * @brief Query the height in pixels of a specific plane.
+ *
+ * @details Given a format of type EImageFormat, a plane index, and the height
+ * in pixels of the 0-th plane, return the height in pixels of the given plane.
+ *
+ * @note
+ *
+ * @param[in] imageFormat: A format of type EImageFormat.
+ * @param[in] planeIndex: a specific plane index.
+ * @param[in] heightInPixels: the height in pixels of the 0-th plane.
+ *
+ * @return the height in pixels of the given plane.
+ *
+ ******************************************************************************/
+size_t
+queryPlaneHeightInPixels(
+    int const imageFormat,
+    size_t planeIndex,
+    size_t heightInPixels
+);
+
+
+/*****************************************************************************
+ * @brief Query the bits per pixel of a specific plane.
+ *
+ * @details Given a format of type EImageFormat and a plane index, return
+ * the bits per pixel of the given plane.
+ *
+ * @note
+ *
+ * @param[in] imageFormat: A format of type EImageFormat.
+ * @param[in] planeIndex: a specific plane index.
+ *
+ * @return the bits per pixel of the given plane.
+ *
+ ******************************************************************************/
+int
+queryPlaneBitsPerPixel(
+    int const imageFormat,
+    size_t planeIndex
+);
+
+
+/*****************************************************************************
+ * @brief Query the bits per pixel of a specific format.
+ *
+ * @details Given a format of type EImageFormat, return the bits per pixel.
+ *
+ * @note
+ *
+ * @param[in] imageFormat: A format of type EImageFormat.
+ *
+ * @return the bits per pixel.
+ *
+ ******************************************************************************/
+int
+queryImageBitsPerPixel(
+    int const imageFormat
+);
+
+
+/*****************************************************************************
+ * @brief Query the image format constant.
+ *
+ * @details Given a MtkCameraParameters::PIXEL_FORMAT_xxx, return its
+ * corresponding image format constant.
+ *
+ * @note
+ *
+ * @param[in] szPixelFormat: A null-terminated string for pixel format (i.e.
+ * MtkCameraParameters::PIXEL_FORMAT_xxx)
+ *
+ * @return its corresponding image format.
+ *
+ ******************************************************************************/
+int
+queryImageFormat(
+    char const* szPixelFormat
+);
+
+/*****************************************************************************
+ * @Dump the information of Image map.
+ ******************************************************************************/
+void
+dumpMapInformation();
+
+/******************************************************************************
+ *
+ ******************************************************************************/
+};  // namespace Format
+};  // namespace Utils
+};  // namespace NSCam
+#endif  //_MTK_HARDWARE_INCLUDE_MTKCAM_UTILS_FORMAT_H_
diff --git a/services/camera/libcameraservice/api1/IBuffer.h b/services/camera/libcameraservice/api1/IBuffer.h
new file mode 100644
index 0000000000..38a1185ae1
--- /dev/null
+++ b/services/camera/libcameraservice/api1/IBuffer.h
@@ -0,0 +1,118 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+#ifndef _MTK_CAMERA_INC_COMMON_CAMUTILS_IBUFFER_H_
+#define _MTK_CAMERA_INC_COMMON_CAMUTILS_IBUFFER_H_
+//
+#include <sys/types.h>
+//
+#include <utils/RefBase.h>
+#include <utils/String8.h>
+
+/******************************************************************************
+ *
+ ******************************************************************************/
+
+namespace android {
+namespace MtkCamUtils {
+/******************************************************************************
+ *
+ ******************************************************************************/
+
+/******************************************************************************
+ *  Memory Buffer Interface.
+ ******************************************************************************/
+class IMemBuf : public virtual RefBase
+{
+public:     ////                Attributes.
+    //
+    virtual int64_t             getTimestamp() const                    = 0;
+    virtual void                setTimestamp(int64_t const timestamp)   = 0;
+    //
+public:     ////                Attributes.
+    virtual const char*         getBufName() const                      = 0;
+    virtual size_t              getBufSize() const                      = 0;
+    //
+    virtual void*               getVirAddr() const                      = 0;
+    virtual void*               getPhyAddr() const                      = 0;
+    //
+    virtual int                 getIonFd() const                        { return -1; }
+    virtual int                 getBufSecu() const                      { return 0; }
+    virtual int                 getBufCohe() const                      { return 0; }
+    //
+public:     ////
+    //
+    virtual                     ~IMemBuf() {};
+};
+
+
+/******************************************************************************
+ *  Image Buffer Interface.
+ ******************************************************************************/
+class IImgBuf : public IMemBuf
+{
+public:     ////                Attributes.
+    virtual String8 const&      getImgFormat()      const               = 0;
+    virtual uint32_t            getImgWidth()       const               = 0;
+    virtual uint32_t            getImgHeight()      const               = 0;
+
+    //
+    //  planeIndex
+    //      [I] plane's index; 0, 1, and 2 refer to 1st-, 2nd-, and 3rd planes,
+    //          respectively.
+    //
+    //  return
+    //      return its corresponding plane's stride, in pixel
+    //
+    virtual uint32_t            getImgWidthStride(
+                                    uint_t const uPlaneIndex = 0
+                                )   const                               = 0;
+
+    virtual uint32_t            getBitsPerPixel()   const               = 0;
+    //
+public:     ////
+    //
+    virtual                     ~IImgBuf() {};
+};
+
+
+/******************************************************************************
+ *
+ ******************************************************************************/
+};  // namespace MtkCamUtils
+};  // namespace android
+#endif  //_MTK_CAMERA_INC_COMMON_CAMUTILS_IBUFFER_H_
diff --git a/services/camera/libcameraservice/api1/StreamImgBuf.cpp b/services/camera/libcameraservice/api1/StreamImgBuf.cpp
new file mode 100644
index 0000000000..1902db8f99
--- /dev/null
+++ b/services/camera/libcameraservice/api1/StreamImgBuf.cpp
@@ -0,0 +1,244 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+#define LOG_TAG "MtkCam/DisplayClient"
+//
+#include "StreamImgBuf.h"
+#include "Format.h"
+using namespace android;
+using namespace NSDisplayClient;
+using namespace NSCam::Utils;
+//
+#include "log/log.h"
+#include "system/graphics.h"
+//
+/******************************************************************************
+*
+*******************************************************************************/
+#define MY_LOGV(fmt, arg...)        ALOGV("[%s] " fmt, __FUNCTION__, ##arg)
+#define MY_LOGD(fmt, arg...)        ALOGD("[%s] " fmt, __FUNCTION__, ##arg)
+#define MY_LOGI(fmt, arg...)        ALOGI("[%s] " fmt, __FUNCTION__, ##arg)
+#define MY_LOGW(fmt, arg...)        ALOGW("[%s] " fmt, __FUNCTION__, ##arg)
+#define MY_LOGE(fmt, arg...)        ALOGE("[%s] " fmt, __FUNCTION__, ##arg)
+#define MY_LOGA(fmt, arg...)        ALOGA("[%s] " fmt, __FUNCTION__, ##arg)
+#define MY_LOGF(fmt, arg...)        ALOGF("[%s] " fmt, __FUNCTION__, ##arg)
+//
+#define MY_LOGV_IF(cond, ...)       do { if ( (cond) ) { MY_LOGV(__VA_ARGS__); } }while(0)
+#define MY_LOGD_IF(cond, ...)       do { if ( (cond) ) { MY_LOGD(__VA_ARGS__); } }while(0)
+#define MY_LOGI_IF(cond, ...)       do { if ( (cond) ) { MY_LOGI(__VA_ARGS__); } }while(0)
+#define MY_LOGW_IF(cond, ...)       do { if ( (cond) ) { MY_LOGW(__VA_ARGS__); } }while(0)
+#define MY_LOGE_IF(cond, ...)       do { if ( (cond) ) { MY_LOGE(__VA_ARGS__); } }while(0)
+#define MY_LOGA_IF(cond, ...)       do { if ( (cond) ) { MY_LOGA(__VA_ARGS__); } }while(0)
+#define MY_LOGF_IF(cond, ...)       do { if ( (cond) ) { MY_LOGF(__VA_ARGS__); } }while(0)
+//
+#define GET_IIMGBUF_IMG_STRIDE_IN_BYTE_FOR_DISPLAY_ROTATION(pImgInfo, plane)  \
+            ((Format::queryPlaneCount(Format::queryImageFormat(pImgInfo->ms8ImgFormat)) >= (plane+1)) ? \
+            ((getImgWidthStride(plane+3)*Format::queryPlaneBitsPerPixel(Format::queryImageFormat(pImgInfo->ms8ImgFormat),plane)))>>3 : 0)
+//
+#define GET_IIMGBUF_IMG_STRIDE_IN_BYTE(pImgInfo, plane)   \
+            ((Format::queryPlaneCount(Format::queryImageFormat(pImgInfo->ms8ImgFormat)) >= (plane+1)) ? \
+            ((getImgWidthStride(plane)*Format::queryPlaneBitsPerPixel(Format::queryImageFormat(pImgInfo->ms8ImgFormat),plane)))>>3 : 0)
+
+/******************************************************************************
+ *
+ ******************************************************************************/
+ImgInfo::
+ImgInfo(
+    uint32_t const u4ImgWidth,
+    uint32_t const u4ImgHeight,
+    char const*const ImgFormat,
+    int32_t const i4ImgFormat,
+    char const*const pImgName,
+    uint32_t const u4Orientation
+)
+    : ms8ImgName(pImgName)
+    , ms8ImgFormat(ImgFormat)
+    , mi4ImgFormat(i4ImgFormat)
+    , mu4ImgWidth(u4ImgWidth)
+    , mu4ImgHeight(u4ImgHeight)
+    , mu4BitsPerPixel(Format::queryImageBitsPerPixel(i4ImgFormat))
+    , mi4Orientation(u4Orientation)
+{
+    ALOGD(
+        "[%s](%s@%dx%d@%d-bit)",
+        ms8ImgName.string(), ms8ImgFormat.string(),
+        mu4ImgWidth, mu4ImgHeight, mu4BitsPerPixel
+    );
+}
+
+
+/******************************************************************************
+ *
+ ******************************************************************************/
+StreamImgBuf::
+StreamImgBuf(
+    sp<ImgInfo const>const& rpImgInfo,
+    int32_t const   i4Stride,
+    void*const      pBufBase,
+    buffer_handle_t*pBufHndl,
+    int const       fdIon,
+    int64_t const   timestamp
+)
+    : IImgBuf()
+    , mpImgInfo(rpImgInfo)
+    , mi8Timestamp(timestamp)
+    , mfdIon(fdIon)
+    , mpBufBase(pBufBase)
+    , mpBufHndl(pBufHndl)
+    , mpANWBuffer(0)
+    , mi4Stride(i4Stride)
+    , mBufSize(0)
+    , mbNeedRotation(false)
+{
+/*
+#ifndef container_of
+#define container_of(ptr, type, member) \
+    (type *)((char*)(ptr) - offsetof(type, member))
+#endif
+    mpANWBuffer = container_of(pBufHndl, ANativeWindowBuffer, handle);
+    MY_LOGE_IF(mpANWBuffer->stride != (int)getImgWidthStride(0),"mismatch stride: %d %d", mpANWBuffer->stride, mi4Stride);
+    MY_LOGE_IF(mpANWBuffer->width  != (int)getImgWidth(),       "mismatch width: %d %d", mpANWBuffer->width, getImgWidth());
+    MY_LOGE_IF(mpANWBuffer->height != (int)getImgHeight(),      "mismatch height: %d %d", mpANWBuffer->height, getImgHeight());
+*/
+#if 1
+
+    if(rpImgInfo->mi4Orientation & HAL_TRANSFORM_ROT_90)    //It also included rot 270 case, because rot 270 = rot90|flipH|flipV )
+    {
+        //If rotated, the fromat must be YUYV
+        //For (Rotated) YUYV Format
+        mBufSize =  getImgWidth() * (GET_IIMGBUF_IMG_STRIDE_IN_BYTE_FOR_DISPLAY_ROTATION(rpImgInfo,0));
+    }
+    else
+    {
+        //If not rotated, the fromat must be YV12
+        //For YV12 Format
+        size_t const y_size = getImgHeight() * (GET_IIMGBUF_IMG_STRIDE_IN_BYTE(rpImgInfo,0));
+        size_t const vu_size= (getImgHeight()>>1) * ((GET_IIMGBUF_IMG_STRIDE_IN_BYTE(rpImgInfo,1)) + (GET_IIMGBUF_IMG_STRIDE_IN_BYTE(rpImgInfo,2)));
+        mBufSize = y_size + vu_size;
+    }
+#endif
+#if 0
+    dump();
+#endif
+}
+
+
+/******************************************************************************
+ *
+ ******************************************************************************/
+StreamImgBuf::
+~StreamImgBuf()
+{
+#if 0
+    MY_LOGD(
+        "%dx%d ion:%d, pBuf/pBufHndl=%p/%p/%p",
+        getImgWidth(), getImgHeight(),
+        mfdIon, mpBufBase, mpBufHndl, *mpBufHndl
+    );
+#endif
+}
+
+
+/******************************************************************************
+ *
+ ******************************************************************************/
+uint32_t
+StreamImgBuf::
+getImgWidthStride(uint_t const uPlaneIndex) const
+{
+    if(mpImgInfo->mi4Orientation == 0 || uPlaneIndex <= 2)
+    {
+        return  (0 == uPlaneIndex)
+            ?   mi4Stride
+            :   ((~15) & (15 + (mi4Stride>>1)))
+                ;
+    }
+    else
+    {
+        int stride = mi4Stride;
+
+        return ((3 == uPlaneIndex) ? stride : 0);
+    }
+}
+
+
+/******************************************************************************
+ *
+ ******************************************************************************/
+void
+StreamImgBuf::
+dump() const
+{
+    MY_LOGD(
+        "[%s](%s@%dx%d@%d-bit@%d), ion:%d, pBuf/pBufHndl=%p/%p/%p, Stride:%d, Timestamp:%lld",
+        getBufName(), getImgFormat().string(), getImgWidth(), getImgHeight(),
+        getBitsPerPixel(), (int)getBufSize(),
+        mfdIon,
+        mpBufBase, mpBufHndl, *mpBufHndl, mi4Stride, (long long)mi8Timestamp
+    );
+}
+
+
+/******************************************************************************
+ *
+ ******************************************************************************/
+uint32_t
+StreamImgBuf::
+getOrientation()
+{
+    return mpImgInfo->mi4Orientation;
+}
+
+/******************************************************************************
+ *
+ ******************************************************************************/
+void
+StreamImgBuf::
+setNeedDisplayRotation(bool bNeed)
+{
+    mbNeedRotation = bNeed;
+}
+
+/******************************************************************************
+ *
+ ******************************************************************************/
+bool
+StreamImgBuf::
+getNeedDisplayRotation()
+{
+    return mbNeedRotation;
+}
diff --git a/services/camera/libcameraservice/api1/StreamImgBuf.h b/services/camera/libcameraservice/api1/StreamImgBuf.h
new file mode 100644
index 0000000000..3f1fd52cc7
--- /dev/null
+++ b/services/camera/libcameraservice/api1/StreamImgBuf.h
@@ -0,0 +1,161 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+#ifndef _MTK_CAMERA_CLIENT_DISPLAYCLIENT_STREAMIMGBUF_H_
+#define _MTK_CAMERA_CLIENT_DISPLAYCLIENT_STREAMIMGBUF_H_
+//
+//#include <utils/RefBase.h>
+//#include <utils/String8.h>
+#include <system/window.h>
+#include "IBuffer.h"
+
+using namespace android::MtkCamUtils;
+
+namespace android {
+namespace NSDisplayClient {
+/******************************************************************************
+ *
+ ******************************************************************************/
+
+
+/******************************************************************************
+ *  Image Info
+ ******************************************************************************/
+struct ImgInfo : public LightRefBase<ImgInfo>
+{
+    String8                         ms8ImgName;
+    String8                         ms8ImgFormat;
+    int32_t                         mi4ImgFormat;
+    uint32_t                        mu4ImgWidth;
+    uint32_t                        mu4ImgHeight;
+    uint32_t                        mu4BitsPerPixel;
+    uint32_t                        mi4Orientation;
+    //
+                                    ImgInfo(
+                                        uint32_t const u4ImgWidth,
+                                        uint32_t const u4ImgHeight,
+                                        char const*const ImgFormat,
+                                        int32_t const i4ImgFormat,
+                                        char const*const pImgName = "",
+                                        uint32_t const u4Orientation = 0
+                                    );
+};
+
+/******************************************************************************
+ *  preview_stream_ops image buffer
+ ******************************************************************************/
+class StreamImgBuf : public IImgBuf
+{
+//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+//  IMemBuf Interface.
+//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+public:     ////                    Attributes.
+    virtual int64_t                 getTimestamp() const                    { return mi8Timestamp; }
+    virtual void                    setTimestamp(int64_t const timestamp)   { mi8Timestamp = timestamp; }
+    //
+public:     ////                    Attributes.
+    virtual const char*             getBufName() const                      { return mpImgInfo->ms8ImgName.string(); }
+    virtual size_t                  getBufSize() const                      { return mBufSize; }
+    //
+    virtual void*                   getVirAddr() const                      { return mpBufBase; }
+    virtual void*                   getPhyAddr() const                      { return 0; }
+    //
+    virtual int                     getIonFd() const                        { return mfdIon; }
+    //
+//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+//  IImgBuf Interface.
+//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+public:     ////                    Attributes.
+    virtual String8 const&          getImgFormat()      const               { return mpImgInfo->ms8ImgFormat; }
+    virtual uint32_t                getImgWidth()       const               { return mpImgInfo->mu4ImgWidth; }
+    virtual uint32_t                getImgHeight()      const               { return mpImgInfo->mu4ImgHeight; }
+    virtual uint32_t                getImgWidthStride(
+                                        uint_t const uPlaneIndex = 0
+                                    )                   const;
+    virtual uint32_t                getBitsPerPixel()   const               { return mpImgInfo->mu4BitsPerPixel; }
+    //
+//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+//  preview_stream_ops Interface.
+//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+public:     ////    Attributes.
+    //
+    inline  native_handle_t const*  getNativeHndlPtr() const                { return *mpBufHndl; }
+    //
+    inline  buffer_handle_t         getBufHndl()    const                   { return *mpBufHndl; }
+    //
+    inline  buffer_handle_t*        getBufHndlPtr() const                   { return mpBufHndl; }
+    //
+//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+//  Operations.
+//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+public:     ////                    Instantiation.
+    virtual                         ~StreamImgBuf();
+                                    StreamImgBuf(
+                                        sp<ImgInfo const>const& rpImgInfo,
+                                        int32_t const   i4Stride,
+                                        void*const      pBufBase,
+                                        buffer_handle_t*pBufHndl,
+                                        int const       fdIon    = -1,
+                                        int64_t const   timestamp= 0
+                                    );
+
+//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+public:     ////                    Debug.
+    void                            dump() const;
+    //
+    uint32_t                        getOrientation();
+    void                            setNeedDisplayRotation(bool bNeed);
+    bool                            getNeedDisplayRotation();
+//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+//  Data Members.
+//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+protected:  ////                    Memory.
+    sp<ImgInfo const>               mpImgInfo;
+    int64_t                         mi8Timestamp;
+    int                             mfdIon;         //  ion shared file descriptor.
+    void*                           mpBufBase;      //  Pointer to the locked buffer base address.
+    buffer_handle_t*                mpBufHndl;      //  Pointer to the locked buffer handle.
+    sp<ANativeWindowBuffer>         mpANWBuffer;    //
+    int32_t                         mi4Stride;      //
+    size_t                          mBufSize;       //
+    bool                            mbNeedRotation; //  for display rotation
+};
+
+
+}; // namespace NSDisplayClient
+}; // namespace android
+#endif  //_MTK_CAMERA_CLIENT_DISPLAYCLIENT_STREAMIMGBUF_H_
-- 
2.17.1

